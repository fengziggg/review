#### 前缀和题目：
1. 连续区间，重复操作(累加，累成)  
2. 或者有f(X op Y) == f(x) OP f(Y) 性质：无视端点的区间差值一致性
都可以转化为 f(Y) = f(X op Y) 逆OP f(X)，然后定起点后一轮计算g(X)，g为起点到X的累次运算
一般都有重复操作，然后哪一个操作是结果无法预测因为结果跟操作次数有关系，这个层面无法避开搜索，只有直接有一个与操作次数挂钩的映射函数，然后在这个函数上寻找答案才有可能避开搜索，类似于积分的问题在原函数层面求解的转化思路

locf 010:连续子序列和出现次数：  
https://github.com/doocs/leetcode/blob/main/lcof2/%E5%89%91%E6%8C%87%20Offer%20II%20010.%20%E5%92%8C%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/README.md  
思路：
1. 前缀和：  
   > 1. 关联思路1：连续，和，区间 ==> 定积分，即定积分的差值，不定积分函数就是前缀和，前缀和只差就是不定积分求定积分，离散化
   > 2. 关联思路2：暴力穷举n²，这里面每定左端后右端展开会有重复项，[1], [1，2]，[1, 2, 3]，... 在[2]的时候就会在1的推导环节有重复内容，已经累积在1的推导上了，抽象出这个重复，就是前缀和用1的推导过程来演化后续所有推导
2. 前缀和之后怎么优化：
   > 1. 这个时候转换问题为一个函数的两个取值差等于一个固定值，即一段区间的面积等于某个值，连续函数无穷解，这里是离散函数，会有这种情况肯定是刚好匹配
   > 2. 带入答案找思路发现答案的区间恰好是g(x) + k = g(y)，其他情况会无法嵌合，所以是遍历+ in 判断(本来到这复杂度是nlogn)
   > 3. 这里还有个性质可以利用就是刚才g是f的积分且f为正，即g单调递增，所以每一个g(x)都不会重复，无重复的元素的 in判断用hash时间复杂度(1)所以总复杂度o(n)

lcof 011:01配对最长连续子序列：  
https://github.com/doocs/leetcode/blob/main/lcof2/%E5%89%91%E6%8C%87%20Offer%20II%20011.%200%20%E5%92%8C%201%20%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/README.md  
这里求回头区间，也用了key val互换的映射，虽然val不唯一，但要求的是maxLen(dist(key))，刚好可以只考虑单项递增一边(记录第一次进入hash)，退化为普通hash情况  

lcof 012: 看错题目(-1h)，以为两数组左右侧也是滑动的
https://github.com/doocs/leetcode/blob/main/lcof2/%E5%89%91%E6%8C%87%20Offer%20II%20012.%20%E5%B7%A6%E5%8F%B3%E4%B8%A4%E8%BE%B9%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/README.md

locf 013: 二位平面的前缀和：
https://github.com/doocs/leetcode/blob/main/lcof2/%E5%89%91%E6%8C%87%20Offer%20II%20013.%20%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C/README.md
