https://www.cnblogs.com/onepixel/p/7674659.html

### 定义：
1. ADT：
2. 数据+关系(运算)+存储

### 存储结构——表：

#### 顺序表(数组):

#### 链表：
- 单/双链表
  > 单链表反序，增删  
  > 双链表增删  
  > 环形双链表  
  
- 带头/不带头
  
#### 静态链表：  
- 结构
- 并查集

#### 顺序表与链表：
||优点|缺点|
|---|---|---|
|数组|随机访问|内存动态分配(头尾扩容和中间扩容)<br>也不是不可以做，但数据体大从新分配大块内存失败频率高，同时中间切片操作会涉及插入修改操作内存范围大|
|链表|内存动态分配|随机访问|

PY中的list的实现，两者结合就是希望有随机访问能力也要有动态扩容能力，折中的点：  
1. 将数组随机访问的缺点--操作涉及的内存范围大(val大的缘故)，改为操作val的指针(val小了且定长
2. 但依旧有realloc和插入修改
3. 再多一次寻址跳转机制

---
### 线性：  
#### 栈
- 线栈/链栈/共享栈
- 后缀表达式实现：
  > 中缀，后缀(a+b*d/e-f => abd*e/+f-)，前缀(右边开始后缀式然后反序❓❓)
  > 按符号判断之前符号的操作(行为分界点是符号)，按优先级决定具体操作内容(弹出还是)，数值一直按顺序

#### 队列
- 队列判空条件: front==rear
- 判满： (rear+1)%size == front，会留一个空，或者引入sizeNum
- 链表队列前删后增，队尾删除无法得到上一个节点，或者多引入一个节点指向尾巴上一个  

#### 串：
- KMP算法：
  > 大思路是模式串的前后缀匹配，模式串本身从断点开始往idx0方向找最长匹配串，不同断点有不同的最大匹配长度：
  >   
    ```void get_next(SString T, int next[]) {
        int i = 1, j = 0;
        next[1] = 0;
        while(i < T.length) {
          if (j == 0 || T.ch[i] == T.ch[j]) {
              i ++;
              j ++;
              next[i] = j;
          } else {
              j = next[j]; // 如果匹配失败，则模拟KMP的思想，对指针j进行回溯
          }
        }
      }```

- Mancher算法(回文直径)：
  > 对称性，已有的回文里面的折中子串左右回文数目叠加，或者类似于快慢指针    
  > [Mancher算法](https://github.com/doocs/leetcode/blob/main/lcof2/%E5%89%91%E6%8C%87%20Offer%20II%20020.%20%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0/README.md#%E6%96%B9%E6%B3%95%E4%BA%8Cmanacher-%E7%AE%97%E6%B3%95)
---
### 树状：  
- 存储方式: 顺序表(下标映射)，链表(向下索引，孩子表示法,孩子兄弟链)，静态链表(双亲节点表示法，向上索引)
- 树/二叉树/森林
- 满二叉树(叶子封顶)/完全二叉树(顺序存储过来)/平衡二叉树(AVL)
- (二叉)树先中后序遍历，树的中序可以转为二叉后遍历
- 由序列构建二叉树(中+先/后)
- 二叉树线索化(叶子空节点指向遍历后继和先驱)
- 二叉树与树转换，二叉树与森林(孩子兄弟链表示)
- 二叉排序树：输入顺序不同构造不同：
  >
  ```# [low, heigh)，左边要进位，防止死循环
    def search(l, e):
        low = 0
        heigh = len(l)
        mid = -1
        while(low < heigh):
            mid = (low + heigh) // 2
            m = l[mid]
            if m == e:
                break
            elif e > m:
                low = mid + 1
            else:
                heigh = mid
        return mid
  ```
- 平衡二叉树AVL: LL/RR(左旋再左移)/LR/RL
- 哈夫曼树：前缀无重复；哈夫曼编码: 拿频率做权重，从小节点开始从下网上构建二叉树，不唯一，贪心思路

#### 红黑树：

#### 跳表(Allco??):

#### 堆，二叉堆，fab堆：
- 插入/删除(去底替换顶部 然后更新)/维护
- 堆排序：不断删除顶点
- 向下更新：**已经有序**的堆顶部插入节点，递归看待都是挑一个子节点替换根节点，然后继续递归被挑选的子树，也是线性的，logN
- 向上更新：**已经有序**的堆底部插入节点，**双亲索引法底到顶是单链线性的**的，然后又按树高度方向看每个路径都是一个搜索树(递增/递减)，所以向上跟新就是个插入交换，logN
- 建堆：NlogN，维护logN
- 优先队列：堆

---
### 图：  
- 
||有向图|无向图|
|---|---|---|
|度|顶点的变数|出度+入度|
|顶点关系|联通|强连通|
|点可互达图|连通图|强连通图|
|联通子图(极大)|(极大)联通分量|(极大)强连通|

- 存储结构：

||邻接表|邻接矩阵|十字链表|邻接多重表|
|---|---|---|---|---|
|有向/无向|√|√|只适合有向|只适合无向|
|适合图|稠密|稀疏|||
|空间复杂度|n2|v+E/v+2E|v+e|v+e|
  > 1. 十字链表：点表和边表，边表就是离散的链接关系对象，每加一个边节点都要**同时更新**两个节点(顶点/边节点)的指向
  > ![image](https://github.com/user-attachments/assets/d0c229ca-83c4-4ed1-b756-7a4b4fd43e84)  
  > 2. 邻接多重表：十字链表的无向缩减

- 搜索：BFS/DFS，可能会有非联通分量
- [图搜索相关](../job_revision/寻路相关.md)
- 生成树：包含所有顶点的无环联通图
  1. 广度优先生成树   
  2. Prim：nLogE?? (当前可接收的最小边，不断转移状态，核心是总权重最小)  
  3. Kruscal：ELogE  
- 寻路：  
  1. djstra: nLogE ?? (当前起点出发的可达最小权重点，不断转移状态，核心是路径权重**最**小，所以不适合**负权图**，非正树权无法保证总权重一直递加)  
  2. floyd：n^3，暴力枚举所有关系，每次设定一个桥接者(遍历)，然后测试能否桥接成功及更新权重(abcd,ad无直连但肯定会更新到ac和bd/cd的时候)，可以**负权重**  
  3. BFS最短路径图：**无权图**，O(n+e)  

- DAG(有向无环图):
  - 拓扑排序：借助DAG，无入度节点开始搜索 / 逆拓扑：无出度节点开始搜索  
  - 最早完成时间：长板时间 / 最晚完成时间：先得到总时长后，逆拓扑减回去，因为总有一些是被长边覆盖的，剪掉边后关键路径的起主要作用不会有空余，剩下的就是最晚时间  

---
### 查找
#### 分块查找
#### B树
#### B+树
#### 哈希
- 装填因子：？？
- 散列函数：除留余数，直接定址(线性)，数字分析法(按位除留余数)，平方取中
- 哈希冲突：
  - 再散列：再Hash一次
  - 拉链法，地址+链表
  - 开放定址：
    1. 线性探测，冲突探索一个线性偏移量，H<i> = ( H<i-1>(Key) + d<i> ) % m，没有重复迭代H(x)，只是平移
    2. 线性探测的基础上间隔为平方数，散列长度为4j+3的素数才能保证探测到所有
    3. 随机序列
    4. 开放定址的删除不能直接删去元素留下空位(会改变Order导致后续的探测错位)，hash分布与Input和Order有关系

---
### 排序
||时间|空间|稳定性|特点|
|---|---|---|---|---|
|插入|O(n2)|O(1)|√|在一个点维持前面序列有序，通过对前面的位置交换，然后迭代该点|
|选择|O(n2)|O(1)|X|在一个点维持前面序列有序，通过在后面进行位序选择，然后迭代该点，交换的时候可能导致不稳|
|冒泡|O(n2)|O(1)|√|有空间交换(比当前基点小的都会被挪下去)，有位序选择(挑最大)|
|希尔|n^1.3|O(1)|X|最小增量排序，分块思想但是是从大到小，块间有序，然后缩小块规模，块的分界规划可能导致两个节点被分隔导致不稳|
|归并|O(nlogn)|O(n)|√|分块思想，从小到大(回溯)，依赖空间，但因为是有序列对比，没有最坏情况|
|快排|O(nlogn)|O(1)|X|根据一个基点，把比基点小的都放到左边(如果小的在大的右边就把他跟第一个大的交换)，每次都位移确定一个位置，会交换空间，有选择位序|
|堆排|O(nlogn)|O(1)|X|好坏都是nlogn，并没有花时间维持严格有序且每次都是更新堆logn|
|---|---|---|---|---|
|计数排序|O(nlogn)|O(n)|稳定|基于哈希空间的有序|
|桶排序|O(nlogn)|O(n)|稳定|哈希空间内再局部排序，桶应该要让里面的内容不交叉(分块查找)|
|基数排序|O(nlogn)|O(n)|稳定|带优先权的计数排序，高位置优先度更高放最后覆盖地位的计数排序|

```
# 快排
def quick_sort(l, low, heigh):
  pivot = low
  low = low + 1
  while(low < heigh):
    while(pivot > low):
      low ++
    while(heigh > pivot):
      heigh --
    swap(low, heigh)
  swap(pivot, low)

  quick_sort(l, pivot-1)
  quick_sort(pivot+1, l)

# 堆排序

# 归并

```
https://www.cnblogs.com/BigJunOba/p/9247682.html  
https://github.com/LtLei/articles/blob/master/data_structure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AD%98%E5%82%A8.md  
> 十字链表
> ![image](https://github.com/user-attachments/assets/c7c12a8e-d485-413c-8971-ae9126da1077)




