locf 010:连续子序列和出现次数：  
https://github.com/doocs/leetcode/blob/main/lcof2/%E5%89%91%E6%8C%87%20Offer%20II%20010.%20%E5%92%8C%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/README.md  
思路：
1. 前缀和：  
   > 1. 连续，和，区间 ==> 定积分，即定积分的差值，不定积分函数就是前缀和，前缀和只差就是不定积分求定积分，离散化
   > 2. 暴力穷举n²，这里面每定左端后右端展开会有重复项，[1], [1，2]，[1, 2, 3]，... 在[2]的时候就会在1的推导环节有重复内容，已经累积在1的推导上了，抽象出这个重复，就是前缀和用1的推导过程来演化后续所有推导
2. 前缀和之后怎么优化：
   > 1. 这个时候转换问题为一个函数的两个取值差等于一个固定值，即一段区间的面积等于某个值，连续函数无穷解，这里是离散函数，会有这种情况肯定是刚好匹配
   > 2. 带入答案找思路发现答案的区间恰好是g(x) + k = g(y)，其他情况会无法嵌合，所以是遍历+ in 判断(本来到这复杂度是nlogn)
   > 3. 这里还有个性质可以利用就是刚才g是f的积分且f为正，即g单调递增，所以每一个g(x)都不会重复，无重复的元素的 in判断用hash时间复杂度(1)所以总复杂度o(n)
