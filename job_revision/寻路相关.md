#### 前置概念：  
1. 连通图与寻路图的区别：  
   全局目标都不一样，即使是全图寻路+均匀代价的图(grid)也是用寻路思路而不是用联通图思路(这个时候连通图推演驱动主要受连通性影响，邻接一圈外直接不可达剪枝，一圈上代价一致，但寻路思路一圈上代价是不一致的是累积值)  
  
2. 用于寻路的图的数据结构：
   空间划分方式差异，对于所有寻路算法都是可以用的：grid，路点(边界点转化)，网格导航  
   数据结构组织方式矩阵形式和链表形式，考虑点无非是空间代价(O(V)多的用grid空间代价大)和时间代价(随机访问需求), 实现算法的便捷考虑  

4. 一些退化和逻辑继承关系：  
   djstra是不需要目标的搜索式驱动的，对于规律的稀疏图(grid：很多情况相邻代价一直，且邻接之外算不可达)，grid代价不同还那寻路还有点作用；如果代价一致，则直接退化为搜索(深搜和广搜看处理openList的方式)  
   同样djstra和稀疏，如果引导函数调整为加入与目标点的距离(Cost = H + G)的考虑，且每一轮次都动态调整，那就是A*(openlist无非是djstra跟新逻辑中选最小这一步的候选对象有序化方便取最值)  

5. 单源，单目标，多目标全图寻路：
   多源一般是靠多次遍历单源实现  
   不管是djstra，A * 都是考每一轮次的最小代价点来推演的，目标点会在第几个迭代的最小代价点出现不确定，所以单目标驱动逻辑是**全图搜索**时候**提前终止**，结束时机不确定   
   djstra本来就是全图寻路没有目标也能正常推进，A*是加入目标启发后的djstra, 本质上是djstra + 输入目标的引导贪心策略 + 提前终止条件  

6. 常用距离：  
   曼哈顿距离: x + y  
   欧式距离：空间直线距离公式

7. 性能瓶颈和加速：

n. 总是感叹djstra思路的精密，一眼扫过去或者用了很多遍之后都平平无奇，而是在补充了其他知识也几年后突然产生一个念头，他是怎么保证全局最优的，平平无奇的步骤，仔细审查之后才觉得这么精妙  
   类似与数学中的最值定理思想，一步推无穷步的推导思路，巧妙的剪枝裁剪问题规模
   

#### Djstra:  
https://www.cnblogs.com/goldsunshine/p/12978305.html  
1. 两步: 收集当前点集的最小邻接点，用最小邻接点的边集更新当前点集(可以用自索引表)
  > ![41b6af369ed72d2e4ddf74da63cecd3](https://github.com/user-attachments/assets/f070822a-4839-4035-bd13-093c5ae8f61d)

2. 贪心：局部最优与全局最优一致：  
  > 局部最优: 当前可达点的最小代价邻接节点  
  > 全局最优：  
  > \$color{#ff0000}{从起点出发}到达任意代考擦点的路径和路径总代价有无数个组合(无数解)，两个变量:目标节点选谁，怎么到达目标节点；   
  > 出发点集合直达待考察点这种路径模式只是无数解中的一解不一定是最优解称为策略S(src->desX),  
  > S只考虑第一个变量目标点选谁的问题而固定了到达目标点的PathTrace，这个时候便可以枚举所有目标点的直达代价然后在里面挑一个直达代价最小的，也一定是全局最优类似极值定理每个状态全局只有一个极值

3. 起点变化：  
  > 拓扑结构都可能变，存在着同代价分支  
  > 代价：  
    >> 无向图代价不会变: 反证--如果代价跟起点相关，那一个起点的最优路径图，即起点外的任意一个点推导的路径图也会经过起点，如果他的总代价比原起点代价更小，那原起点在推导最优路径图的时候推导出来的就不是最优(矛盾点，原最优图完全可以是另外起点的拓扑)  
    >> 有向图: 方向不同conn都不一样，代价不同很容易理解

4. **Prim算法的区别**：  
  很容易混淆，因为两者思路的全局最优原则类似，都是每次**筛选**可以候选的点集中找与之链接代价最小的一个，又都是在更新新点链接的时候**剪枝**剪掉待更新点的重复链接减少下一轮的搜索规模，区别是新点更新链接的方式不一样
  > djstra: 剪枝的依据是累积到当前节点的源点出发的路径总代价+nextConn 对比 上一次到目标节点的累积总代价，比较的数值是从源点出发的总代价，通过**累加**和**由源点推导出**来这两个逻辑来体现，d[k+1] = min(d[k], **acc**[k]+nextConn)  
  > prim: 剪枝的依据就是新节点到所有目标节点的conn与所有目标节点上一版本的conn代价做对比，全局目标只是路径总和最小，不是从某个起点出发的路径总和，所以直接不用考虑起点只需考虑每个新更新节点带来的变化，d[k+1] = min(d[k], nextConn)  

5. 复杂度：  
  暴力搜索N！，djstra：O(n2)，堆优化可以O(nlogn)(用堆来存储对外链接表，每次修改堆o(logn)，取最值o(1))  

----
#### A*:  
https://blog.howardlau.me/programming/a-star-algorithm.html  
```
give Src, Tar
def Cost(Node)  
def Heuristic(Node)  
def Neibor_UnClosed(Node)
setOpen(Src), setClose
while openSet:
  // 贪心挑选最小值驱动
   node = setOpen.pop(0)
   setClose.add(node)

   // 最小值更新所有候选
   costList = [Cost(node) + Heuristic(node) for node in Neibor_UnClosed(node)]
   update openSet:
      if nodeNeibor in openSet and  Neibor_UnClosed(node):
         choice mini price one update trace
      else:
         openSet.add(nodeNeibor)
```
1. A*与djstra的继承关系提到A * 是目标和启发函数的特化djstra，所以总体流程还是djstra的choiceMini和UpdateCandidate  
2. openList就是djstra中所有目标集中的**目前可达子集**，所以A * 同样是全局最优的，启发式让他的终结时间不可预测
3. 不管数据格式是grid还是其他，两个算法都可以，但是A*需要比较好的定义启发函数，比如空间问题的可以用距离函数，抽象图则需要再看
4. 最优：是否最优看H(n),如果没有H(n)退化为djstra是最优路，如果没有G(n)退化为贪心不是最优，H(n)需要满足启发一致性才可以保证是最优：
   > 启发一致性：h(n) <= c(n, n’) + h(n’) => c(n, n’) == f(n') - f(n) >= h(n) - h(n')，其中 n’ 是 n 的所有邻接节点，c 是两个节点间的真实距离，并且要满足 h(G) = 0，其中 G 是终点
   > 即g的增长与h的**增长负相关**且起点终点互斥互补
   > 反证法：如果引导函数是距离负数，且存在多条路径，A*是找到即停止，所以会找出最长的路径
5. 优化：  
   数据规模250*250 ~ 6 * 10^4上去取整10^5 ，遍历一遍控制0.1s(6frame)，则给到每个数据单元的时间10^(-6)~1us，py语句一个get/set可能要0.n us
   > openList中业务排序规则优化：mask,static+dynamic
   > 二叉堆：
   > 基本单位尺度划分
   > 多进程并行计算

----
#### JPS:  
前提：A*在条件约束下的优化：  
> 无权图：轴方向用了直线搜索，默认不存在权值导致的虽然距离长了但代价更小的情况，即是完全的按距离作为权值的寻路(或者说权值增长与空间距离一致)  
> 格子坐标：格子坐标才可以离散的划分空间，拆解为有限步骤：水平，垂向，斜向再度拆解  
> 性能优化的前提是减少了候选队列搜索规模或者说减少了多方向入度的重复检查(是同一个东西，djstra系列适用于有权是因为会根据权重跟新最小入度的节点，重复搜索的功劳)，所以jsp不适合有权图  
> 如果阻挡太少(极端就是无阻挡)那么会退化为搜全图，这种情况下性能不一定好  

强迫邻居：
- 定义是考虑了四个因素(dir, cur, parent, target)  
- 都是在阻碍的角点
- 定义是p,c,t, p到达t必须要经过c最短，ct是一对强迫邻居
- 大致是前进方向+阻挡方向的另一个角点

跳点：
- 起点或者终点，或者强迫邻居点
- 非这两者的情况下，如果其xy垂直射线上有强迫邻居，或者斜线上有强迫邻居也是跳点
![image](https://github.com/user-attachments/assets/97fce497-06e7-4e81-aa6b-9d4b200d5437)

实现思路：
**对于某个方向**，出现强迫邻居，那该点为强迫邻居的跳点，定义是考虑了三个因素(dir, jump, Fneibor)  
搜索：四向搜索，斜向逐步推进，推进的过程再次拆解为四向(一般只剩下两向)，碰壁或者遇到终点或者遇到跳点停止

----  
#### 网格导航：  
1. 生成网格
- 体素化
- 体素等高面(过滤)，体素分区，找打最大/连续/无重叠/区内无洞的区域Region，是粗糙轮廓表示的二维平面，(简单的 分水岭算法)
- 找出精细轮廓DetailCounter，就是体素为单位长度的轮廓构成的平面(SimplifyCounter)精细化的结果
- 多边形拟合PoliMesh
- 地形拟合DetailMesh
得到的Mesh是单位内可以全可达的单元

2. 基于网格寻路
https://zhuanlan.zhihu.com/p/35100455

----
#### RVO:  
VO：  
![image](https://github.com/user-attachments/assets/ad81b3dd-a0bf-46f7-a6d3-41a71f3b7afd)  

简化问题为点是否相遇问题，两个因素：
- 两个点各自的绝对速度(矢量)
- 切换为这个速度的时候，两个点各自的位置绝对位置  
==>
- 由两个人的绝对速度得到相对速度，这时是相当于一个点不动的情景
- 两个人的绝对位置的到相对位置**差**向量
- 相对速度与相对位置向量**共线**两点在这个状态下就一定会相遇  
==>  
- 所以一旦相对速度和相对位置差确定，那追击状态就是确定的
- 演算的过程中两者的worldPos，共线的时候不会改变方向(位置差，不是速度)，会一直保持共线
- 如果不共线的时候，位置差会一直改变，按着相对位置速度所在直线改变
- 不管共不共线，危险三角一直在变化(碰撞共线是fov变大)

如果一个是球，另一个是理想化点的情况：
- 球可以看作很多个候选点集群
- 所以对于某个点A跟一群点B'，如果A与任意B'会碰撞，那就会与这个球碰撞
- A与球B的相对速度跟 A与B的球心位移差可能不共线，但可能与某个B'是共线的
  
- 碰撞范围跟危险三角(位置差)和相对速度Vab'有关
- A移动的过程**危险三角在变化**，但是如果某个相对速度Vab'与与B'共线，那危险三角移动也会保证这个相对速度一定在危险三角内(即碰撞，所以一开始计算能否碰撞与中途用不同的危险三角计算结果都是一致会就是会不会就是不会)
- 危险三角的范围**不是Va的范围，是Va-Vb**的速度的范围(与危险三角的范围保持一直)，所以为了直观可以画出引发变化的源头Va的范围即：
![image](https://github.com/user-attachments/assets/41d9070e-5f53-4ba8-b3c0-3af0ed0137d5)

RVO:
上面的VO为了避免碰撞可以让各自视角下的Va偏移到危险三角外，但会产生抖动，一般RVO是有主速度的遇到障碍才临时变速，没有就恢复原速度，但两次迭代位置未脱离危险三角视角的时候还会继续计算偏移
就让各自偏移一半，下一不不会得出彼此完全安全的结论而恢复原始速度(应该刚好一直相切)

----
从障碍物的角度看待对可能的所有寻路策略的影响，会有什么信息有用？？(类似于预处理场景)

----
一些链接：  
https://zhuanlan.zhihu.com/p/695656054
