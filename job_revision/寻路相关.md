#### Djstra:  
https://www.cnblogs.com/goldsunshine/p/12978305.html  
1. 两步: 收集当前点集的最小邻接点，用最小邻接点的边集更新当前点集  
  > ![41b6af369ed72d2e4ddf74da63cecd3](https://github.com/user-attachments/assets/f070822a-4839-4035-bd13-093c5ae8f61d)

2. 贪心：局部最优与全局最优一致：  
  > 局部最优: 当前可达点的最小代价邻接节点  
  > 全局最优：  
  > \$color{#ff0000}{从起点出发}到达任意代考擦点的路径和路径总代价有无数个组合(无数解)，两个变量:目标节点选谁，怎么到达目标节点；   
  > 出发点集合直达待考察点这种路径模式只是无数解中的一解不一定是最优解称为策略S(src->desX),  
  > S只考虑第一个变量目标点选谁的问题而固定了到达目标点的PathTrace，这个时候便可以枚举所有目标点的直达代价然后在里面挑一个直达代价最小的，也一定是全局最优类似极值定理每个状态全局只有一个极值

3. 起点变化：
  > 拓扑结构都可能变，存在着同代价分支  
  > 代价：  
    >> 无向图代价不会变: 反证--如果代价跟起点相关，那一个起点的最优路径图，即起点外的任意一个点推导的路径图也会经过起点，如果他的总代价比原起点代价更小，那原起点在推导最优路径图的时候推导出来的就不是最优(矛盾点，原最优图完全可以是另外起点的拓扑)  
    >> 有向图: 方向不同conn都不一样，代价不同很容易理解
4. Prim算法的区别：
  很容易混淆，因为两者思路的全局最优原则类似，都是每次**筛选**可以候选的点集中找与之链接代价最小的一个，又都是在更新新点链接的时候**剪枝**剪掉待更新点的重复链接减少下一轮的搜索规模，区别是新点更新链接的方式不一样
  > djstra: 剪枝的依据是累积到当前节点的源点出发的路径总代价+nextConn 对比 上一次到目标节点的累积总代价，比较的数值是从源点出发的总代价，通过**累加**和**由源点推导出**来这两个逻辑来体现，d[k+1] = min(d[k], **acc**[k]+nextConn)
  > prim: 剪枝的依据就是新节点到所有目标节点的conn与所有目标节点上一版本的conn代价做对比，全局目标只是路径总和最小，不是从某个起点出发的路径总和，所以直接不用考虑起点只需考虑每个新更新节点带来的变化，d[k+1] = min(d[k], nextConn)

----
#### A*:  
  > 

#### JPS:  
  >  

#### ...:  
