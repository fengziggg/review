#### 前置概念：  
1. 连通图与寻路图的区别：  
   全局目标都不一样，即使是全图寻路+均匀代价的图(grid)也是用寻路思路而不是用联通图思路(这个时候连通图推演驱动主要受连通性影响，邻接一圈外直接不可达剪枝，一圈上代价一致，但寻路思路一圈上代价是不一致的是累积值)  
  
3. 用于寻路的图的数据结构：
   空间划分方式差异，对于所有寻路算法都是可以用的：grid，路点(边界点转化)，网格导航  
   数据结构组织方式矩阵形式和链表形式，考虑的可能有稀疏关系，实现算法的便捷考虑  
 
4. 单源，单目标，多目标全图寻路：
   多源一般是靠多次遍历单源实现  
   不管是djstra，A * 都是考每一轮次的最小代价点来推演的，目标点会在第几个迭代的最小代价点出现不确定，所以单目标驱动逻辑是**全图搜索**时候**提前终止**，结束时机不确定  
   djstra本来就是全图寻路没有目标也能正常推进，A * 没有目标就会退化为djstra，不存在有目标但依旧全图寻路的A *  
   A * 本质上是djstra + 提前终止条件 + 输入目标的引导贪心策略  

6. 一些退化和逻辑继承关系：


#### Djstra:  
https://www.cnblogs.com/goldsunshine/p/12978305.html  
1. 两步: 收集当前点集的最小邻接点，用最小邻接点的边集更新当前点集(可以用自索引表)
  > ![41b6af369ed72d2e4ddf74da63cecd3](https://github.com/user-attachments/assets/f070822a-4839-4035-bd13-093c5ae8f61d)

2. 贪心：局部最优与全局最优一致：  
  > 局部最优: 当前可达点的最小代价邻接节点  
  > 全局最优：  
  > \$color{#ff0000}{从起点出发}到达任意代考擦点的路径和路径总代价有无数个组合(无数解)，两个变量:目标节点选谁，怎么到达目标节点；   
  > 出发点集合直达待考察点这种路径模式只是无数解中的一解不一定是最优解称为策略S(src->desX),  
  > S只考虑第一个变量目标点选谁的问题而固定了到达目标点的PathTrace，这个时候便可以枚举所有目标点的直达代价然后在里面挑一个直达代价最小的，也一定是全局最优类似极值定理每个状态全局只有一个极值

3. 起点变化：  
  > 拓扑结构都可能变，存在着同代价分支  
  > 代价：  
    >> 无向图代价不会变: 反证--如果代价跟起点相关，那一个起点的最优路径图，即起点外的任意一个点推导的路径图也会经过起点，如果他的总代价比原起点代价更小，那原起点在推导最优路径图的时候推导出来的就不是最优(矛盾点，原最优图完全可以是另外起点的拓扑)  
    >> 有向图: 方向不同conn都不一样，代价不同很容易理解

4. **Prim算法的区别**：  
  很容易混淆，因为两者思路的全局最优原则类似，都是每次**筛选**可以候选的点集中找与之链接代价最小的一个，又都是在更新新点链接的时候**剪枝**剪掉待更新点的重复链接减少下一轮的搜索规模，区别是新点更新链接的方式不一样
  > djstra: 剪枝的依据是累积到当前节点的源点出发的路径总代价+nextConn 对比 上一次到目标节点的累积总代价，比较的数值是从源点出发的总代价，通过**累加**和**由源点推导出**来这两个逻辑来体现，d[k+1] = min(d[k], **acc**[k]+nextConn)  
  > prim: 剪枝的依据就是新节点到所有目标节点的conn与所有目标节点上一版本的conn代价做对比，全局目标只是路径总和最小，不是从某个起点出发的路径总和，所以直接不用考虑起点只需考虑每个新更新节点带来的变化，d[k+1] = min(d[k], nextConn)  

5. 复杂度：
  暴力搜索N！，djstra：O(n2)，堆优化可以O(nlogn)

----
#### A*:  
  > 

#### JPS:  
  >  

#### ...:  
