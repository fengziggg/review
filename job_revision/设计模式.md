开闭原则：同类替换的代码都不要写在本该New的地方，有另外的上下文支持任意扩充  
单一职责：——  
向下-里氏替换原则：父类的行为子类也能执行(子类不改变父类行为含义)  
向上-依赖倒置：下层依赖上层，具体依赖抽象，不可以反过来  
迪米特原则：高内聚低耦合  
接口隔离：最小接口原则，不依赖冗余接口  
组合原则：组合大于集成(不等于组合模式)  

---
很多设计模式看代码组织架构是几乎一样的，设计模式关心的是意图(用来做什么和预测会怎么用)，组织结构只是支撑意图的   

组合思想的结构： 
||单向持有|持有+反向依赖|链式结构|
|---|---|---|---|
|——组合思路相关——|——|——|——|
|桥接模式|√|||
|表观模式|√|||
|适配器模式|√|||
|装饰器模式|√||O|
|代理模式|√||O|
|享元模式|√|||
|——行为相关——|——|——|——|
|观察者||√||
|责任链|√||O|
|中介模式||√||
|状态机模式||√||
|策略模式|√|||

---
1. 适用场景
2. 其他模式对比(适用场景增加理解)
3. 与其他模式组合
4. 
5. 一些特别的亮点：
  装饰器模式： 动态卸载，功能增强，无感知，面向切面
7. 实际应用

---
### 构造模式
#### 工厂方法：
> ![image](https://github.com/user-attachments/assets/1da397cb-760e-42d3-a437-8a42b9c1836c)  
1. 目的：  
   - 吧零散在代码各处的所有new A给统一管理起来，用方法的方式，在替换类的时候不会受硬编码的影响检查多处  
   - new A就对应createA，new B就对应createB，...  
   - 主要目的是便于统一管理，重点不在创建的对象，也不在于类型种类A/B/...有多少种  
   - 复用主要是继承重写这个给带工厂的上下文，对于一个上下文实例是违反开闭原则的

#### 抽象工厂方法：
> ![image](https://github.com/user-attachments/assets/48f73b19-fa05-4247-a9a0-4b0001b13708)  
1. 目的：
   - 工厂方法只是解决了A要替换A‘可以直接只在统一入口处硬编码改一处然后重新运行或者实例话一个新上下文
   - 对于依赖对象的组合(FA/FB/FC/...)，不同上下文可能会要求子对象的组合(FA'/FB*/FC^/...)，这个时候即使有环境标志，也需要在上下文里面根据环境标志分支重复定义各个方法(不讨论跟组合模式结合的桥接器模式)
   - 违背开闭原则在上下文写拓展，所以直接把(FA/FB/FC/...)的组合抽象为对象就是抽象工厂了
   - 主要针对(FA/FB/FC/...)的组合情况，也不在于对象创建本身

#### 生成器模式(Builder)：
> ![image](https://github.com/user-attachments/assets/14122a7b-9bda-4164-b9d6-cae12963037f)  
1. 目的：
   - 针对**一类对象创建的过程中的初始化环节**(与上面两个不同)，根据需求不同(参数)初始化流程会不一样
   - 或者不同类对象也行，直接对Builder进行派生了
   - 吧所有流程拆分(函数或者直接根据参数标记分支)都写在构造然后用参数来选择构造流程，会导致参数量过多且很多没适用上参数
   - 流程分开到不同子类，但这里是一个类只是初始化内容不一样
   - 所以依旧吧所有的初始话手段划分出来(全集ProcessN)，但是托管给另外一个对象(Builder)，不需要派生也不会污染构造，可以按需调用初始化
   - 这个只是定义划分，还有调用划分，可以再交给Director，这里编码调用的配置，比如分支标记调用不同Builder组合

#### 原型模式：
> ![image](https://github.com/user-attachments/assets/075598d5-1f69-41f6-9617-b46c155a3980)  
1. 目的：
   - 克隆自己，外部很多时候不能克隆(私有变量内部不配合的话)
   - 原型注册表，与生成器模式一起，**就可实现用数据字段来模拟子类的效果**，可以代替集成，而且还是同一个基类
   - ECS的Entity，虽然只记录了Com的Type签名，但正好是签名这个属性数据表征了不同Entity的类型

#### 单例模式：
> ![image](https://github.com/user-attachments/assets/10d978d4-1736-4cab-bd87-5ddfc442df96)  
1. 目的：
   - 全文访问
   - 保护单例，全局变量能被替换
   - 但是问题是不安全，违背单一原则
   - 懒汉，饿汉模式
  
---
### 结构模式(组合思想,**持有**其他类实例)
跟其他类组合：  
其他多个类A/B/C  
#### 桥接模式：
> ![image](https://github.com/user-attachments/assets/21617951-89cd-4622-bdc9-b32b7c2bc1c0)  
1. 目的：
   - **不同维度的行为的拓展问题**
   - 不断派生继承或者多继承都不可取，派生会导致代码碰撞和耦合，多继承不能动态替换(IS，每次都要直接换掉整个平替对象而不是对象的功能变化)
   - C组合了A和B和...，他是为了解决继承的问题，但本来的目的行为扩充还是要的，所以C的行为可能是FAs * FBs * ...
   - 方法上看是笛卡尔乘积，是增加
   
#### 外观模式：
> ![image](https://github.com/user-attachments/assets/f3628fbc-25fa-4a5f-8434-84abc9c1f7e4)  
1. 目的：
   - **对外抽象，或者说封装思想**
   - 一个外观下的子模块间的行为受外观上下文管理，但子模块间也可以是相互访问的，即网状结构(Manager)
   - 外观可能形成上帝模块，超级耦合
   - 方法上看是减少的，只抽取核心对外的方法

其他单个类：  
#### 适配器模式：
> ![image](https://github.com/user-attachments/assets/66376084-43f4-4353-9349-f6dc191dfa0d)  
1. 目的：
   - 调用着的需求可以在依赖对象上可以得到支持，但不能直接调用需要组织依赖对象的行为
   - 用适配器封装依赖对象，在适配器上写组织逻辑组织，符合调用着的调用接口
   - 对于被封装着是组织已有接口为一个新接口
   - 与装饰器模式结构不同，无法递归层层委托  
2. 一些特别的亮点： 动态卸载，功能增强，无感知，面向切面  


跟基类自己：  
数量上单个：  
#### 装饰器模式：
> ![image](https://github.com/user-attachments/assets/2770f854-90c7-4611-bebf-a8645af867b8)  
1. 目的：
   - 拓展被封装对象行为，面向切面
   - 继承类持有一个同类对象，链式嵌套，基类的所有行为都要被继承，且调用自己的逻辑处理完后都要层层委托下去
   - 原有接口的加强


#### 代理模式：
> ![image](https://github.com/user-attachments/assets/26b7eb25-421e-4176-8a6b-a84cdd8bf7e5)  
1. 目的：
   - 限制被封装对象的行为，面向切面
   - 结构与装饰器模式一致，但目的不同，一般是原封不动转发请求不会改动结构，但很多是对被委托者的保护或者对请求的限制
   - 远程连接，数据库等，可能会控制委托者的生命周期(懒加载)
   - 转发原有接口


数量上多个
#### 组合模式：
> ![image](https://github.com/user-attachments/assets/a97a5d6d-faca-49fd-a189-9c5942aabace)


多个类，数量上也多个
#### 享元模式
> ![image](https://github.com/user-attachments/assets/444d4fe1-9dc1-4504-ab5b-842e2fa127a6)  
1. 目的：
   - 类似与桥接拆分子类并且用持有的方式，但主要是用于节省内存的
   - 类似于分表，差异化实例用引用持有共享实例(单例)
   - 享元可以有多个，且享元内数据是不可改动，单例是可以的

---
### 行为模式(行为就是方法，这里主要都是针对方法的一些模式)  

行为的实例化：  
#### 指令模式  
> ![image](https://github.com/user-attachments/assets/bdaab2a7-3aac-4846-9215-1ec1a4c12856)  
1. 目的：
  - 方法是一系列计算和子方法的封装(逻辑)，同时还需要调用才能生效，调用的变量是时间和地点(时序)  
  - 一般直接写在代码里的方法调用满足逻辑封装但时序是硬编码，如果有些情况变数是方法的调用时间(观察者)，或者方法间的相互顺序(不同业务组织不同责任链的定向)，硬编码就很难拓展
  - 所以把对方法的时序变量进行封装，就是要有一个变量/对象来代表方法的**调用**，然后组织这些变量的时序
  - 封装方法调用需要：方法对象，参数，作用对象(Receiver)；(之前自己的实现是吧Receiver或者整个context当参数传入在cmd写逻辑，这里的receiver是具体实现操作的地方，cmd本身不带逻辑)


行为实例的应用，关注某中请求的所有定制化行为   
#### 观察者模式  
> ![image](https://github.com/user-attachments/assets/f97543d4-cbc4-49ad-9ce7-f58f4ce987d0)  
1. 目的：
  - 对某一类请求，所有关注者自定义行为(回调方法)
  - 组合结构：publisher持有各subcrisber，这个结构仅仅只是为了支撑意图

  
行为实例的应用，关注一类请求会有多少种通用行为响应  
#### 责任链模式  
> ![image](https://github.com/user-attachments/assets/4d4c9096-d46e-4771-bd57-54c3f0ce0004)  
1. 目的：
  - 对于一些公共的处理行为候选者，不同的请求会有那些候选者(Handler)进行响应
  - 与装饰器模式差别：装饰器是对原有行为的封装加强，最终本质还是最底层的行为结果，这个是多个平级行为中部分生效并且影响后续请求的生命周期

  
行为的约束(严格控制对**某些类**访问行为)：  
针对特定需求：集合对象，需求是遍历**完**所有元素的访问约束  
#### 迭代器模式
> ![image](https://github.com/user-attachments/assets/8aa22bbf-8604-4bf5-81da-ae4422f06b42)  
1. 目的：
  - 集合对象要暴露数据给外部适用但又不想暴露自己的数据结构和内部逻辑
  - 集合对象**自己提供**的一个专门用来访问的对象，访问细节自己把控，迭代方式自己把控
  - 核心目的是不遗漏的遍历完所有元素
  - 一般两者双向依赖


针对特定需求：实现回退操作，面临访问私有成员问题的解决方案
#### 备忘录模式
> ![image](https://github.com/user-attachments/assets/3c9cf0d9-f8e9-4123-a36d-1ba92730875b)  
1. 目的：
  - 回退要么在外部修改数据对象的属性，要么是复制快照数据对象，但这些都要数据对象本身支持: 提供修改接口或者克隆接口，这不太可能
  - 无法满足上述要求，核心目的其实不是要他的数据，只是为了用他的数据**自己控制时序来实现回退**，关注这点那其实可以不要数据细节，自己只管时序切换
  - 数据对象自己提供封装的快照数据对象，只有自己能访问：嵌套定义类型，或者外部定义的类型但屏蔽所有get/set只靠数据对象自己连接进去后使用封装的原生数据
  - 外部只缓存封装对象整体，无法任何访问细节(get/set)
  - 可以结合原型模式，限制访问，但提供了克隆和apply方法
  - 一般两者双向依赖

  
行为的限制(尽量约束类**之间**的访问行为) 
类之间的相互访问，减少关系网  
#### 中介模式
> ![image](https://github.com/user-attachments/assets/f0286385-322c-42f4-b088-8b9acef0fde9)  
1. 目的：
  - 对象实例之间有太多相互访问了，对标表观模式，限制网状调用行为  
  - 约定接口或者数据，全部只跟中介的接口或者统一数据段，间接交互(地图生成delegate)，子模块之间的相互依赖(线性或者网状)靠中介传达
  - 行为间不再直接知道其他行为(隔离开)
  - 持有+反向依赖


类之间的相互访，梳理关系网  
#### 状态机模式
> ![image](https://github.com/user-attachments/assets/b6417673-0dbe-4c8c-b378-f8c0821f8c5c)  
1. 目的：
  - 关注点是每个状态对象**之间的相互访问的拓展性**，fsm这个时候有点类似表观行为了(但关注点不是对外提供接口，而是状态之间的切换)
  - 优化的是在上下文一直if分支处理拓展和修改，但状态之间是需要相互可知的(状态跳转在每个状态里面自行决定，这种全局把握是比较容易混淆人的)
  - 另一种方式是吧条件转移表单独列出(邻接矩阵法，有多少状态，状态间的相互转移关系一目了然)，然后fsm动态的根据这个table进行跳转到对应状态，状态间不再直接关系其他子状态的跳转(但参数可以传递上下文状态)
  - 持有+反向依赖


行为的多态化
组合思想的多态化
#### 策略模式
> ![image](https://github.com/user-attachments/assets/d37e57ca-4cd2-4741-8bf9-6b516f3099d9)  
1. 目的：
  - 一些列业务(行为)的封装，多态思想，指令是单个行为的封装


继承思想的多态化
#### 模板方法
> ![image](https://github.com/user-attachments/assets/4c5a04d4-121b-4021-a647-0995ffc056f3)  
1. 目的：
  - 步骤抽取，只给在步骤上重载，基于继承
  - 与策略可以相互结合，比如一个模板方法的上下文，抽象方法就是策略，或者反过来策略里面用模板方法进行约束


双分配问题
#### 访问者模式
> ![image](https://github.com/user-attachments/assets/97c3ffcd-bae6-4484-b406-58cb0c33cbce)  
1. 目的：
  - 装饰器模式是对不同的对象的访问都定义不同的装饰器  
  - 这里是用一个对象访问所有不同对象(可能是同一父类下的)的不同方法(一般是同功能但实现和参数不一样，可能重载或者直接不同名)  
  - 在上下文用if加类型判断，抽取为直接吧类型判断放在不同被访问类里面，但是visitor自己还是要针对每种类型重载或者重定义访问方法  
  - 这里visitor的访问方法和不同的被访问对象是耦合的
  - 双分配是指既重载又再重载里面多态导致动态绑定安全起见变成静态绑定？？


