开闭原则：同类替换的代码都不要写在本该New的地方，有另外的上下文支持任意扩充
单一职责：——
向下-里氏替换原则：父类的行为子类也能执行(子类不改变父类行为含义)
向上-依赖倒置：下层依赖上层，具体依赖抽象，不可以反过来
迪米特原则：高内聚低耦合
接口隔离：最小接口原则，不依赖冗余接口
组合原则：组合大于集成(不等于组合模式)

---
### 构造模式
#### 工厂方法：
> ![image](https://github.com/user-attachments/assets/1da397cb-760e-42d3-a437-8a42b9c1836c)  
1. 目的：
   - 吧零散在代码各处的所有new A给统一管理起来，用方法的方式，在替换类的时候不会受硬编码的影响检查多处
   - new A就对应createA，new B就对应createB，...
   - 主要目的是便于统一管理，重点不在创建的对象，也不在于类型种类A/B/...有多少种

#### 抽象工厂方法：
> ![image](https://github.com/user-attachments/assets/48f73b19-fa05-4247-a9a0-4b0001b13708)  
1. 目的：
   - 工厂方法只是解决了A要替换A‘可以直接只在统一入口处硬编码改一处然后重新运行或者实例话一个新上下文
   - 对于依赖对象的组合(FA/FB/FC/...)，不同上下文可能会要求子对象的组合(FA'/FB*/FC^/...)，这个时候即使有环境标志，也需要在上下文里面根据环境标志分支重复定义各个方法(不讨论跟组合模式结合的桥接器模式)
   - 违背开闭原则在上下文写拓展，所以直接把(FA/FB/FC/...)的组合抽象为对象就是抽象工厂了
   - 主要针对(FA/FB/FC/...)的组合情况，也不在于对象创建本身

#### 生成器模式(Builder)：
> ![image](https://github.com/user-attachments/assets/14122a7b-9bda-4164-b9d6-cae12963037f)  
1. 目的：
   - 针对**一类对象创建的过程中的初始化环节**(与上面两个不同)，根据需求不同(参数)初始化流程会不一样
   - 或者不同类对象也行，直接对Builder进行派生了
   - 吧所有流程拆分(函数或者直接根据参数标记分支)都写在构造然后用参数来选择构造流程，会导致参数量过多且很多没适用上参数
   - 流程分开到不同子类，但这里是一个类只是初始化内容不一样
   - 所以依旧吧所有的初始话手段划分出来(全集ProcessN)，但是托管给另外一个对象(Builder)，不需要派生也不会污染构造，可以按需调用初始化
   - 这个只是定义划分，还有调用划分，可以再交给Director，这里编码调用的配置，比如分支标记调用不同Builder组合

#### 原型模式：
> ![image](https://github.com/user-attachments/assets/075598d5-1f69-41f6-9617-b46c155a3980)  
1. 目的：
   - 克隆自己，外部很多时候不能克隆(私有变量内部不配合的话)
   - 原型注册表，与生成器模式一起，**就可实现用数据字段来模拟子类的效果**，可以代替集成，而且还是同一个基类
   - ECS的Entity，虽然只记录了Com的Type签名，但正好是签名这个属性数据表征了不同Entity的类型

#### 单例模式：
> ![image](https://github.com/user-attachments/assets/10d978d4-1736-4cab-bd87-5ddfc442df96)  
1. 目的：
   - 全文访问
   - 保护单例，全局变量能被替换
   - 但是问题是不安全，违背单一原则
   - 懒汉，饿汉模式
  
---
### 结构模式(组合思想,**持有**其他类实例)
跟其他类组合：  
其他多个类A/B/C  
#### 桥接模式：
> ![image](https://github.com/user-attachments/assets/21617951-89cd-4622-bdc9-b32b7c2bc1c0)  
1. 目的：
   - **不同维度的行为的拓展问题**
   - 不断派生继承或者多继承都不可取，派生会导致代码碰撞和耦合，多继承不能动态替换(IS，每次都要直接换掉整个平替对象而不是对象的功能变化)
   - C组合了A和B和...，他是为了解决继承的问题，但本来的目的行为扩充还是要的，所以C的行为可能是FAs * FBs * ...
   - 方法上看是笛卡尔乘积，是增加
   
#### 外观模式：
> ![image](https://github.com/user-attachments/assets/f3628fbc-25fa-4a5f-8434-84abc9c1f7e4)  
1. 目的：
   - **对外抽象，或者说封装思想**
   - 一个外观下的子模块间的行为受外观上下文管理，但子模块间也可以是相互访问的，即网状结构(Manager)
   - 外观可能形成上帝模块，超级耦合
   - 方法上看是减少的，只抽取核心对外的方法

其他单个类：  
#### 适配器模式：
> ![image](https://github.com/user-attachments/assets/66376084-43f4-4353-9349-f6dc191dfa0d)  
1. 目的：
   - 调用着的需求可以在依赖对象上可以得到支持，但不能直接调用需要组织依赖对象的行为
   - 用适配器封装依赖对象，在适配器上写组织逻辑组织，符合调用着的调用接口
   - 对于被封装着是组织已有接口为一个新接口
   - 与装饰器模式结构不同，无法递归层层委托  
2. 一些特别的亮点： 动态卸载，功能增强，无感知，面向切面  


跟基类自己：  
数量上单个：  
#### 装饰器模式：
> ![image](https://github.com/user-attachments/assets/2770f854-90c7-4611-bebf-a8645af867b8)  
1. 目的：
   - 拓展被封装对象行为，面向切面
   - 继承类持有一个同类对象，链式嵌套，基类的所有行为都要被继承，且调用自己的逻辑处理完后都要层层委托下去
   - 原有接口的加强

#### 代理模式：
> ![image](https://github.com/user-attachments/assets/26b7eb25-421e-4176-8a6b-a84cdd8bf7e5)  
1. 目的：
   - 限制被封装对象的行为，面向切面
   - 结构与装饰器模式一致，但目的不同，一般是原封不动转发请求不会改动结构，但很多是对被委托者的保护或者对请求的限制
   - 远程连接，数据库等，可能会控制委托者的生命周期(懒加载)
   - 转发原有接口
   
数量上多个
#### 组合模式：
> ![image](https://github.com/user-attachments/assets/a97a5d6d-faca-49fd-a189-9c5942aabace)

多个类，数量上也多个
#### 享元模式
> ![image](https://github.com/user-attachments/assets/444d4fe1-9dc1-4504-ab5b-842e2fa127a6)  
1. 目的：
   - 类似与桥接拆分子类并且用持有的方式，但主要是用于节省内存的
   - 类似于分表，差异化实例用引用持有共享实例(单例)
   - 享元可以有多个，且享元内数据是不可改动，单例是可以的



1. 适用场景
2. 其他模式对比(适用场景增加理解)
3. 与其他模式组合
4. 
5. 一些特别的亮点：
  装饰器模式： 动态卸载，功能增强，无感知，面向切面
7. 实际应用
