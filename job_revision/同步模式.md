#### 状态同步和帧同步对比


||状态同步|帧同步|
|---|---|---|
|核心差别|计算逻辑在服务端,服务端有世界逻辑|服务端只转发,计算逻辑客户端各自推演,各个客户端都一份世界逻辑|
|服务器压力和安全|计算压力大,但安全|压力给到客户端,但容易安全问题|
|重连和回放(离线)|回放靠状态快照文件较大且回放精度受快照精度决定且需要回放服,但断线易恢复|回放简单本身就有所有的增量操作,记录文件只有操作所以小,但断线回复要复盘推演到特定状态|
|开发难度|开发难度大,cs有共同代码的部分(或者按协议各自实现),但定位问题容易,可以知道数据是哪里出问题后分c/s排查|前期开发简单类似于单机,后期难排查,不同步问题,设备问题,随机数，以及失真放大|
|同步程度|有误差,预测(??)和纠正|精确|
|网络要求|允许延迟,但有误差和拉回之列|要求高,严格锁帧一卡全卡|
|流量压力|说是流量较大,同步属性量大的时候|少人流量少,例子是王者|

#### 同步问题(部分状态或者帧同步)：  
https://www.gabrielgambetta.com/client-side-prediction-live-demo.html 同步逻辑，其实状态和帧同步都有这个模拟的流程和对应问题
1. 每个人的同步都要等待，即输入后有延迟，操作总是滞后于真实输入，包括自己的视角
2. 等待确保了每个人的同步是逻辑一致，即在等待的前提下，每个人看到的内容就能保证大家都看到了,且都服务器世界的副本
3. 自己的端 $\color{#FF0000}{看自己的操作}$ 可以预表现，然后靠服务端回报来确认：  
   > - 如果自己的操作表现快于回包，则预表涉及的是对全局世界修改的(互斥资源/下一个操作依赖上一个操作的结果的)，则预测的误差会被放大在第一个回报到来之前的所有操作预测可能不断失真，直到开始收到回包，对比第一个误差处进行修正和抛弃错误的预测(拉回)  
   > - 如果预测表现比较久回包比较快，那放心预表现，每一个预表现误差会及时被修正
4. 他端的逻辑总是包含了等待时间的，如果自己的端不包含预测，那他端和自己的端的表现都是逻辑同步(他们的 $\color{#FF0000}{表现}$ 对应服务器逻辑时间线是一致, $\color{#ff0000}{操作}$ 对应的一般是真实世界时间线);
   包含预测的话自己视角的两个客户端表现，跟他端的两个客户端表现对应服务器时间不一致,自己端是假的
5. 时间精确的要求不高的情况下(精确到帧的程度)，可以通过服务器收集操作后集中分发处理结果(帧同步就是直接分发操作)，服务器先收集再处理可以合并掉一些中间状态就不用每个人的操作都触发广播造(比如可以合并10个任意人提交的操作后处理结果每个人只广播一次出去，丢失掉一些中间过程的信息细节，但可能有些根本不需要这些细节比如即时游戏中人物脸部朝向，原先可能是10*n个人的发送次数，这里就很类似锁帧同步的模式了，与服务器跟新频率有关
6. 同步模式从异步触发机制变成了定时轮询，他端表现进行插值表现，对自己的修正可以加点调和不要让每个服务器回复直接生效，不然拉回严重，这个时候自己的操作时序与服务器逻辑时间是有差距的


![d2e823a6f8246db8aadd49b9325bea1](https://github.com/user-attachments/assets/098e1a4e-02f8-4153-b3b2-3230955888ef)

---
#### 状态同步相关的问题：
1. 状态同步比帧同步更难实现所有玩家和逻辑世界的一致同步，帧同步有逻辑帧所有的操作用逻辑帧作为标号，即使各端的帧可能会有一点差异但是基于逻辑帧来复盘世界可以保证不会有什么遗漏
2. 状态同步主控玩家的操作需要服务器同步给所有人，每个人以发送给服务器的实际时间和各个玩家收到服务器的广播实际时间为准，也会收到网络延迟波动的影响
   - 同比要靠通知服务器和服务器广播，这里有2RTT时间
   - 为了世界同步有几个基础要求：
     - 等待：每个人都要等到服务器回包才能表示对应的包内容（操作）已经在逻辑世界（Server）同步了，即使是自己客端操作也是要等到回包才能被当作有效请求进行进一步操作
     - 竞争：状态同步就意味着客端看到的永远延迟于服务器的世界，更延迟于他端客户端此时的实时操作，如果有些资源对于游戏来说是互斥竞争的（比如相互射击，相互可见性一个要看到对方一个要跑入掩体，或者滑雪赛跑比赛），那么延迟高的意味着收到其他玩家的请求会更久（这种对于需要基于他端的操作做出进一步反应的游戏来说就有天然的劣势），也意味着同样的一个操作（无视前面这种交互的情景下各做各的）会在到达世界时间进行请求生效的时机点更后，如果是有竞争即意味着会被网速更好的玩家抢先请求生效慢的被仲裁失败抛弃
       > 滑雪游戏两个玩家都同步进去了，然后网速好的按下前进（他的世界时间会先收到游戏同步开始点）先在server世界同步然后开始运动
       > 网速差的收到同步开始的世界时间也会慢，然后他按下移动的请求到达服务器的时间也会比第一个慢，然后在等待自己的请求生效的中间，就会先收到第一个玩家开始移动了，自己还没收到自己的move生效即自己还没动对方先动了
       > 如果都以玩家自己逻辑时间线上的时间，即世界时间不一样但只要两者同步过了Server时间起点，再发给服务器的时候都以这个逻辑时间起点off为准，那Server收到的请求都是要往前预测的，冲突也要往前处理，不好处理（对网速快的玩家体验感不好）
     - 客户端预测：等待导致所有人的体验都不好，主控客户端会进行客户端预测，但这就涉及到预测端的世界和服务器同步世界不一致的问题
   - 三段机制：前摇-结算-后摇，和其原因：
     - 前摇-打断窗口：对即时act游戏（要基于其他人的反应作出反应比如拳王这种类型），如果状态同步的时候主控操作者发给服务器之后服务器立马生效广播给所有玩家，即使是所有人都等待的模式，他端玩家也是没有时间打断第一个玩家的操作的，因为他收到的时候已经是服务器确认过了广播开了，对于这种模式的游戏需要把发起操作这个动作变成延时的即留一段窗口时间用于给玩家作出反应，应该要比RTT大（不考虑服务器往前预测的情况），所以把技能阶段抽象出前摇并且带时间窗口，同时这个窗口用于做与结算无关的预表现
     - 结算：对于立即生效的类型，过了前摇没被打断就意味着强制生效，竞争就按世界时间的先后竞争来，对于延时的类型比如轨迹型的，状态同步有个问题就是滞后性，主控在收到结算请求后开始表现轨迹，这个时候他端在没有同步到最新世界或者已经同步了一些信息后作出的一些行为能打断主控的结算的（比如无意间瞬移到弹道上导致结算目标切换，服务器也无法预知），服务器进行修正，但对于预表现的客户端，他的这个中途修正可能在自己预表现完之前也可能在之后，这一点服务器可以进行预测判定（预测预表现的客户端此时到哪了），主控客户端则进行差值过度，则主控客户端看到的表现因为叠加了自己的预表现和差值逻辑，跟他端收到的完全同步信息，两者表现会不一样（弹道轨迹中途切换目标，切换的轨迹主控应该会跑到更后然后又转向目标，他端就是按照中断时节开始转向目标），但最终的结果（命中换人了）是各端一致的
     - 后摇：服务器在结算阶段插入打断，再广播给主控的时候需要RTT，而且主控预测了所以他的终点时间会提前，中断请求过去的时候可能主控已经表现结束了（提前一个RTT），所以这里
    
