#### 状态同步和帧同步对比


||状态同步|帧同步|
|---|---|---|
|核心差别|计算逻辑在服务端,服务端有世界逻辑|服务端只转发,计算逻辑客户端各自推演,各个客户端都一份世界逻辑|
|服务器压力和安全|计算压力大,但安全|压力给到客户端,但容易安全问题|
|重连和回放(离线)|回放靠状态快照文件较大且回放精度受快照精度决定且需要回放服,但断线易恢复|回放简单本身就有所有的增量操作,记录文件只有操作所以小,但断线回复要复盘推演到特定状态|
|开发难度|开发难度大,cs有共同代码的部分(或者按协议各自实现),但定位问题容易,可以知道数据是哪里出问题后分c/s排查|前期开发简单类似于单机,后期难排查,不同步问题,设备问题,随机数，以及失真放大|
|同步程度|有误差,预测(??)和纠正|精确|
|网络要求|允许延迟,但有误差和拉回之列|要求高,严格锁帧一卡全卡|
|流量压力|说是流量较大,同步属性量大的时候|少人流量少,例子是王者|

#### 同步问题(部分状态或者帧同步)：  
https://www.gabrielgambetta.com/client-side-prediction-live-demo.html 同步逻辑，其实状态和帧同步都有这个模拟的流程和对应问题
1. 每个人的同步都要等待，即输入后有延迟，操作总是滞后于真实输入，包括自己的视角
2. 等待确保了每个人的同步是逻辑一致，即在等待的前提下，每个人看到的内容就能保证大家都看到了,且都服务器世界的副本
3. 自己的端 $\color{#FF0000}{看自己的操作}$ 可以预表现，然后靠服务端回报来确认：  
   > - 如果自己的操作表现快于回包，则预表涉及的是对全局世界修改的(互斥资源/下一个操作依赖上一个操作的结果的)，则预测的误差会被放大在第一个回报到来之前的所有操作预测可能不断失真，直到开始收到回包，对比第一个误差处进行修正和抛弃错误的预测(拉回)  
   > - 如果预测表现比较久回包比较快，那放心预表现，每一个预表现误差会及时被修正
4. 他端的逻辑总是包含了等待时间的，如果自己的端不包含预测，那他端和自己的端的表现都是逻辑同步(他们的 $\color{#FF0000}{表现}$ 对应服务器逻辑时间线是一致, $\color{#ff0000}{操作}$ 对应的一般是真实世界时间线);
   包含预测的话自己视角的两个客户端表现，跟他端的两个客户端表现对应服务器时间不一致,自己端是假的
5. 时间精确的要求不高的情况下(精确到帧的程度)，可以通过服务器收集操作后集中分发处理结果(帧同步就是直接分发操作)，服务器先收集再处理可以合并掉一些中间状态就不用每个人的操作都触发广播造(比如可以合并10个任意人提交的操作后处理结果每个人只广播一次出去，丢失掉一些中间过程的信息细节，但可能有些根本不需要这些细节比如即时游戏中人物脸部朝向，原先可能是10*n个人的发送次数，这里就很类似锁帧同步的模式了，与服务器跟新频率有关
6. 同步模式从异步触发机制变成了定时轮询，他端表现进行插值表现，对自己的修正可以加点调和不要让每个服务器回复直接生效，不然拉回严重，这个时候自己的操作时序与服务器逻辑时间是有差距的


![d2e823a6f8246db8aadd49b9325bea1](https://github.com/user-attachments/assets/098e1a4e-02f8-4153-b3b2-3230955888ef)
