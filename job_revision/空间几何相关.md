---
#### 场景管理
空间加速结构：将空间以某种方式进行分割，搜索存在性，范围搜索，空间位置测试都能辅助剪枝起到加速
主要目的是剔除，空间分割是结构基础，**但不是要求一定严格空间互斥分割**
- Grid
- 四叉树/八叉树
- BVH(BinaryVolumnHierarchy)
- BSP(BinarySpacePlane)
- KDTree

Grid：
均分，更新简单，但是一个数据可能存储于多个分割单位

四叉树/八叉树：  
1. 与二叉树对比：
  - 普通链表二叉树是非严格控制边界的，跟插入顺序有关，可能先插入的值跟上层很进导致两层之间边界很小，另一边又很大，AVL也只是平很了里面的长度来让边界启发式的均衡，也不是严格的
  - 顺序表二叉树就是严格限制边界
  - 四叉树八叉树是链表结构，但又类似于顺序表二叉树，是严格控制边界的，每个插入的数据key一定会划分到某个固定边界的树节点
2. 是空间划分，节点是代表一个空间的容器，是空间节点构成树而不是数据构成树
3. 每个树节点是一个空间，所以有边界(2d/3d)，存储的数据可能是点，也可能是有范围的空间对象aabb，分割精度上：
  - 可以约定最小粒度，则不管是点还是aabb对象都可以由有限个树节点来记录
  - 也可以动态细分下去：
  - 如果是点，那四叉树八叉树可以任意精度细分，目标是争取每一个点都有唯一的包围节点
  - 如果是aabb，则一般找刚好能容纳整个aabb的大小层级，然后用最多4(2d)/8(3d)个来记录aabb
  - 这种情况下，高层级的非叶子节点也会记录对象，底层级则不记录被高层级收纳的对象
4. 优化：松散树：
  - 让出边大于入边，出边只判定为出空间节点的边，如边指判定为进入空间节点的边，最好是两倍
  - 效果距离：出的删除的慢，入的加载的快，两边频繁切换的话两边都延迟删除，整体延迟删除了
![image](https://github.com/user-attachments/assets/38c113bb-d67f-45cb-909d-d9758ca32170)


BVH：
1. 不用再严格划分空间，也不是按维度划分(2d/3d每个轴都划分)，只有逻辑上的二叉划分：
   - 所有的内容都存储在叶子节点上，都是二叉
   - 非叶子节点有尺寸信息
   - 节点之间可能重合，但没所谓，空间划分主要是索引位置相关的时候有**一定**随机访问的能力，重合的部分会触发重复检测不会有遗漏
   - 而且重复的过程左右子树内也有进行剔除的
2. 构建树的思路：
   - SAH(表面积启发)：均等划分一个轴统计表面积权重后抉择那个区间的边界作为分界
![image](https://github.com/user-attachments/assets/973e9309-f8df-4f7f-bbb2-51bfd4e17a94)


BSP：
1. 用面将空间不停细分 
2. 面可以用点法式表示，也可以用系数表示Ax+by+Cz+D=0，然后带入(x0, y0, z0)的结果>0则在背面快速判断
3. 构建的过程需要调整均衡，涉及到遍历尝试，大致是遍历每个面，构建BSP后统计均衡性：面左右各自的面数
![image](https://github.com/user-attachments/assets/b74ace97-2718-410f-a829-95a55449e514)


KD-Tree：
固定了轴向，交替分割的BSP

---
#### 碰撞检测：
GJK:
- 闵可夫斯基差：A-B就是B的原点镜像与A的和，闵可夫斯基和：A在B的轮廓上笔刷叠加B得到的形状
- 碰撞检测基础，闵可夫斯基差形经过原点(只有有交集的点才会得出一个原点)
- 算法优化：直接算单形是否经过原点，迭代构建单形
  > 支撑点算法找最远点，二阶单形为三角形
  > 初始随机一个方向找两个支撑点，以两个支撑点线段的垂线方向找支撑点，与方向点乘>0过三角形，则纳入单形
  > 判断单形是否过原点(向量顺序叉乘可以做到，或者重心法)，过则结束，不过则继续迭代
  > 什么时候停止呢??
