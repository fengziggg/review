---
2024.11.18  
[对照面经](https://www.nowcoder.com/discuss/596064413442949120)

#### 项目架构:
公司lw引擎+公共代码+项目代码  

引擎提供游戏的基础共功能模型,特效,资源加载,场景,摄像机,光照声音,网络等基础功能  

公共进行了一些各项目共用常用的模块封装: 登录,网关,UI封装,屏蔽字,防成谜,实名认证,邮箱,充值等  

项目代码整体情况:  

1.状态同步
  - [状态同步/帧同步](同步模式.md)
  通过协议的方式与服务端拟定协议事务,进行状态同步

2.代码框架:MVC,ECS,ECGame
  - [MVC,MVP,MVVP](项目框架.md#mvcmvpmvvm)  
    大部分业务,包括UI模块都是用MVC的形式组织起来,不好的一点是出现了模块嵌套,但并非mvc本身问题,mvc本身可能存在没有必要存在view或者model的情况和ctrl臃肿
  - [ECS](项目框架.md#ecs)  
    战斗相关的业务用ECS进行改版尝试,服务端是用的ECS,为了与服务端同步好进行属性同步,同时方便的卸载加载组件,以及代码结构简单,但调试还不太方便
    
3.用到的设计模式：  
  - [单例](设计模式.md)  
  - [观察者](设计模式.md)  
  - [策略模式](设计模式.md)  
  - [指令模式](设计模式.md)

4.代码管理:
  svn,传统,co,update,reverse,merge,commit
  工具少量git(fetch,pull,push,merge,commit):  
  - 云效ci/cd蓝图  

5.开发流程:
  - 项目自行检出引擎工程进行编译(bat执行Cmake,ide编译工程,ide版本要求),编译过程中可以配置一些操作启用禁用,自定义拓展引擎功能(在引擎c层上开发,一般是效率考虑)  
  
  - 专门的公共代码检出和更新工具,检查版本和依赖进行公告脚本代码更新
  
  - 各种编辑器(没有集中):  
    数据编辑器(导表): 做了一些封装,用他的规则就可以对数据文件自定义解析,一般解析为py文件格式是字典等可以直接加载数据类型或者类化为对象再自定义一些工厂函数使用
    
    UI编辑器: 记录UI控件布局为配置文件,再解析为py的指令文件,继承UI对象的时候用指定文件路径名的方式执行布局指令集来初始化UI,将存粹UI布局隐藏独立开后又方便的在下方可以编写view相关的操作逻辑且还内聚为view 

    法术编辑器: 针对操作的都是引擎基础节点的公共方法,比如播动画,节点生命周期管理,空间操作,吧这些操作抽象为时间轴,时间轴的集合就是操作的集合,时间轴的时序就是法术播放的时序逻辑,附带condition, 发信号等控制指令就可以编排与外界的交互,对应的法术配置序列文件可以静态话下来以及需要的时候切换和维护,没有用状态机  

    地图编辑器: 2d瓦片地图,在对应的瓦片上放置单位就行,后续增加了一些预制组合之类;随机地图则只需要编辑关键点,联通关系,资源生成模板;  

    资源编辑器: 主要是编辑特效,gfx,mod, 例子发射器(基础元素面片,广告牌等的动画,生命周期,运动轨迹控制的组合),针对模型的材质纹理的周期性调整(UV动画)  
  
  - ci/cd平台: 内外网隔离  
    ci负责一些资源批处理工作,如代码文件化,资源检查(图片清理,模型大小,贴图缺失),资源自动加工(生成索引文件,导表到处)等,依旧处于内网  

    cd是将项目按固定格式组织后用提供的打包脚本吧资源,脚本打包加密为特定文件或者目录后部署在指定的域名下面,然后经过一系列校验手段(文件发布审核,md5+下载url的索引文件发布审核)进行发布到外网,游戏/游戏平台内置会去对比最新的索引文件,发现差异则根据索引内容引导下载更新,用于整包/补丁/工具文件的外网发布

#### 主要模块:  
- 通信  
  ecgame框架:  
  1.主要是封装了与服务端的通信功能,用dll的形式暴露接口给客户端使用
  2.服务器还支持了一个把部分逻辑集成到客户端的功能(打包为脚本文件),他们会通过ci吧他们一部分逻辑(不涉及安全的逻辑,如buff计算推演逻辑)集成到客户端,然后两边公用一份代码,两端都通过协议交互与之交互;共用逻辑,减轻服务端压力.
  通信的形势是拟定协议的方式,给要通信事务进行编号,拟定事务携带的参数类型,数量,用一份特定格式的协议文件进行记录,两端同步每次加新协议就要约定好后同步解析  
  解析出来的是对应事务的py函数,函数做的内容就是将参数压包和解包为协议规定格式的字节流,上层直接调用业务py函数,隐藏了这些字节流压解细节,然后给dll字节流后会用socket进行通信([socket](知识点misc.md)❓)自己实践过一次,但查乱码之类麻烦,后面用引擎封装的([大小端](知识点misc.md#大小端)❓)

- 业务
  - 特效  
    gfx，mod，叠加特效(❓),指令模式(❓)+组合模式  
    特效有一份完整的游戏资源目录：tex，model，mod/gfx嵌套？？
    gfx是粒子特效等的组合和对外封装
    mod是结合模型的进一步封装，可以指配到具体模型的具体动作的特效，组合了gfx和子mod
  
  - 模型：  
    1. 前期的模型规范，参考其他项目组和主观感受，原先2w顶点，面数(❓),定制依据(❓),后面定制为(❓)，一些分析工具的开发，模型性能上限测试，同屏200个不掉帧
    2. 角色对象的封装：
       ![image](https://github.com/user-attachments/assets/122a4600-1c15-4085-b89f-59e4ac7977a2)  

  - 战斗:
    六边形棋盘格回合战旗
    - 场景管理(区域事件)：
      1. 场景的生命周期管理：场景资源预加载，入场时间提前到游戏开始，实现战场秒加载；或者用分帧实现排列展开程序的入场展现方式，最终用了前者；异步加载表现不好；
      2. 区域事件：比较简单，主要是一些与逻辑位置相关的事件机制，服务端也有类似逻辑，服务端的自行实现后只通知客户端表现结果，比如陷阱伤害；客户端的仅用于客户端表现的区域事件，不如靠近建筑遮挡视野后建筑半透

    - 框架和数据结构：  
      状态同步+指令模式（所有操作都是指令，用队列进行管理）+ECS：  
      1.在客户端视角，大部分指令都有客户发起和服务端广播表现两部分，少量不需要客户端发起行为(服务器逻辑驱动)：  
         等待输入指令，移动指令，普攻指令，魔法/技能指令，防御指令  
      2.客户端是行为收集就是简单的协议通知服务器，会有一些检查操作比如操作范围越界，目标选取逻辑等  
      3.客户端对服务端回复指令进行演绎，所有回复结果在服务器统一计算各端只是演绎结果可以保证一致性，也方便排查问题(结果不一致则确定是服务器问题还是单端客户端，客户端是某个客户端还是全都，还是网络问题)  
      
    - UML：
      1.战斗实例上下文
      2.各种系统：
      3.各种组件：
      4.表现指令队列和指令对象
      
    - 表现指令队列：  
      指令队列的逻辑本身简单，顺序执行指令，指令里面获取上下文和操作目标(一般是角色或者空节点)，但有一些情况：  
      > 1. 嵌套指令：  
        召唤魔法————这类魔法都有一个通用的施法动作表现指令，但在表现一半的时候需要开始召唤逻辑即入场指令，但指令是顺序串行(服务端是线性发送，表现时机是客户端动态计算的，对于服务端而言不知道什么表现上的嵌套逻辑，只知道是两个指令，客户端数据结构也是线性队列)  
        不改变指令结构，那只能通过更复杂的指令组合来描述这个业务，比如吧通用施法指令拆解为两块，前摇指令和后摇指令，然后通过前摇+Spawn(入场+后摇)的方式来实现，但这样服务端的指令组织变复杂需要关心到客户端的表现细节(为了表现拆分也在指令组织上进行拆分)，客户端需要对所有的通用施法表现(每个角色都有自己的施法表现)进行拆分，动画资源在施法这一个上*3且有工作量  
        所以对指令进行扩展支持子嵌套子指令，约定主次指令的顺序比如先发主指令再子指令，再约定指令搜索规则比如子指令自动搜索最近的一个目标类型指令进行嵌套，就可以在主指令执行生命周期内执行其他指令，具体时序可以靠信号机制触发比如动画k帧触发信号，特定信号进行子指令执行；思路类似于指令组  
      > 2. 多段法术：  
      简单的可以直接服务端发送多个指令，首位相接即可，但指令的串行就会在每个指令表现完之后才进行下一个，而很多时候多段表现衔接是不等一个指令完全执行完就开始下一个表现，这种情况将多段衔接的逻辑下沉的魔法表现系统，里面也是个指令模式各个表现是单独的指令且可以组织为文件，组织为首段法术文件(攻击，关联，受击)和链接法术表现(关联，受击)，然后就是在一个法术指令内串联这些法术文件播放；法术指令的拆分不放到上层业务是因为上层指令需要与服务端同步，上移意味着服务端或者客户端业务需要关心到表现细节
      > 3. 事务/指令合并：
      有些指令类型是高频重复出现，会带来重复计算：比如某个buff导致的多个属性更新，其实是一个事务，但由于属性更新协议粒度问题导致需要多个协议来通知触发多次更新逻辑，可以通过指令缓存，然后识别可合并指令，在执行前执行一次指令合并来实现(类似于cocos中自动合批渲染逻辑)，具体实现上是处理为连续属性跟新指令才自动合批，不连续的属性更新指令有时候表现就是要被其他指令隔断开的：比如受伤扣血后又触发补血，中间得先表现受伤扣血，在恢复动画，然后再回血扣字
      > 4. 防阻塞：  
      可能指令实现有bug，然后一直阻塞住整个队列执行(比如没正常释放)，需要一些超时保底自动推进机制  
      > 5. 乱序：  
      比如前期客户端有自己插wait()的操作，如果逻辑异常在处理一个正常的wait0()里面先插入了一个客户端wait1()，然后会收到服务器对第一个wait0()的表现act0()但被wait1()卡住没表现,且第一个wait0()没有结束回合还能继续操作又收到第二个wait2(),队列为[wait1,act0,wait2],这个时候再操作使用了wait1()和执行了后续的act0()，但服务端会以为这是wait2()执行又给后续act1()，队列[wait2,act2],实际表现就是点第一下客户端没反应，第二下的时候执行了第一下的表现，点第三下的时候执行第一段到第二段的表现，这跟用户操作的预期是不一样的，而且服务端也会错误的收到第三个wait的输入；处理办法可以是给cmd都加编号这样指令执行的时候就可以进行一些异常检查；项目的处理是禁止这种乱序的源头比如不允许客户端插入wait，还有加一些指令队列实时打印进行调试  

    - 技能管线：预测机制：  
      ![a5a6e588c9efb82091fbf137bfa9b01](https://github.com/user-attachments/assets/110f5e4c-ff0e-4e9b-8d10-b08ca412c3a1)  
      https://weibo.com/ttarticle/p/show?id=2309404808077663928613  
       > - 分两次请求发起技能和命中结算而不一次，在即时游戏中由于同步的滞后原因，客户端在对当前同步内容做出回应的时候，无法预测到有没有当前世界的更新内容(会影响客户端做出的操作的结果的内容)正在路上，如果一次技能请求同时请求是否能发起和命中程度，那返回的结果可能没命中，命中且与预测部位一致，命中但由于有操作信息未更新过来所以命中信息有偏差，且命中细节有时候并不在服务器(比如精确到模型的部位)，即这次请求里面包含来太多情况粒度不一致，收到回包即使与预测可释放一致，也还需要重新计算名字情况并发起请求
       > - 讨论表现时间足够长足够回包到来的情况，分两次请求且两次都带预变现，那第二个请求的预测误差更大(基于第一个)，完全可以借用第一个预测的表现时间，在收到第一个回复排除一些情况和同步了更新的信息(比如不可释放)后马上进行第二个命中请求，并将请求信息缓存，等真正要执行命中请求的时候直接回复  
       > - 如果用中间层，那类似于热插拔结构，与没有中间层对接上没差别，但中间层在透明化的同时帮忙进行缓存数据和做一些小动作  
       > - 如果是回合游戏，在一个回合的逻辑时间长度上，不可能有任何他端操作会改变服务器世界数据导致本端操作逻辑过期而导致表现误差，更不用考虑延时这种级别的脏数据问题  
      
    - ECS：  
      ![bdf08114f88d142039b20c5dab0cf45](https://github.com/user-attachments/assets/d4cb4593-2f31-4e14-8597-637ea7c97c35)
      全局的事件系统作为通信手段，低耦合关联Sys和Com
      大部分通信发生在Com和Sys的切面时机: 创建销毁更新
      逐帧驱动框架运行，也可以进行指令控制(ECS框架级别的指令)比如用上下文管理实现属性更新的合并  
      
    - 魔法：
      针对表现逻辑的指令系统，与表现相关的操作都封装为指令，在系统内用代理模式操作角色代理，然后用时间轴以及蓝图的形式提供给编辑工作者精细的支持编辑角色的移动，动画帧级别的表现，外部对系统的交互用传入参数的方式传入角色对象和一些动态数据如位置，系统对外部用事件的方式进行通知和携带参数比如事件名称，对应的特定事件参
      ![99f8a3cebb32de1ef56ad922d113aa3](https://github.com/user-attachments/assets/e144b09d-197c-435b-82dc-8e42e1f9af55)
      
    - 加速：
      
    - 六边形地图：
      ![05574be53ea45aaba771739c6b7d5b0](https://github.com/user-attachments/assets/d71ad69c-2fd4-4ea7-893f-df91ea7c6681) 
      轴坐标系/立方体坐标系qrs   
      > 1. 向量运算:(基坐标有所不一样),  $\color{#ff0000}{浮点向量的取整(round(max(axial))修正)}$ ,向量和像素互换  
      > 2. $\color{red}{坐标转换}$ ：axial/cube <--> offset  
      > 3. 采样: DDA, freshham??    
      > 4. 范围：max(q, r, s) == dist, circle遍历，max/min求交集，Rotate(为同dist的圈中rotate，六边形圈为基点)  
      > 5. $\color{red}{寻路}$ ：无差别，huristic: max(q)+max(r)  
      > 6. 射线检测：breshham 🛠️，https://www.redblobgames.com/articles/visibility/(碰撞点/边排序后按角度检测碰撞) 🛠️

      https://www.redblobgames.com/grids/hexagons/#map-storage  

      
    - 录像：  
      一般是帧同步记录操作，或者状态同步记录状态切片文件(精度问题和文件储存占用)  
      客户端的录像：数据更新都是通过协议来的，所以即使没有用帧同步的方式，也不用快照，记录协议来实现录像(相当于服务端假数据)  
      有些特殊情形要处理，有些服务端指令回来后会导致客户端阻塞等待，然后需要客户端操作来解锁并回复(即整个回合的正常推进需要客户端操作环节)，这个时候记录只会记录回复协议不会记录协议之上的任何客户端操作:  
      > 1. 统计这种客户端操作，支持对这些全局阻塞操作的跳过开关
      > 2. 需要客户端协议演绎之前绑定一些专门测试用的客户端操作模拟(不要真的操作不然操作本身也会发协议)
      > 3. 替换客户端指令，重定向走真正的客户端操作(比较难，可能设计UI操作,比如鼠标如何拖拽或者点击某些地方)
      
      目前遇到的就只有等待输入会阻塞游戏一个情况，用了方案2，暂时只是用于排查bug工具
      
    - 观战：
      状态同步，直接用世界数据重建场景，后续接收广播即可实现
      
    - 联机：

     - 行为树：
   
    - AI：
   
      
  - UI系统/管理/优化/携程应用
    - 分辨率适配UI  
    - 2^n尺寸  
    - 响应逻辑链条  
 
  - 场景管理
    - 状态机
    - 流程
 
  - 地图
    - 随机地图生成  
      市面地图类型：平面像素蒙版地图，格子地图，网格地图，箱庭地图(暗黑), 北境，群星，泰拉，养恐龙那个  
      地图分类：静态地图(专门的资源制作团队(策划，美术，或者两者配合)出的静态资源)，全动态随机地图(饥荒，H4)，折中(一些静态资源+一些动态逻辑堆叠)  
      参考：英雄之时，H3地图论文，redblob  
      相关知识：noice，维诺图
      其他实现思路：
      H4实现思路：
      > 1. UML：Zone，Hex，Tile，Config (图)  
      > 2. 高频算法：寻路，元胞生成，坐标转换  
      > 3. 重构过程：数据依赖梳理，调试，随机种子复现逻辑，util，业务扩展性，delegate，导表配置模板复用，可视化编辑器  
      
      > Zone是数据容器，里面关联了对应的Hex，Zone最主要的数据是ID，用于顶层玩法的规划(与角色阵营相关)  
      > - Zone可配置数据有ID，控制Zone尺寸的HexSize，锚定Zone的中心HexPos, Zone内Hex联通环路的概率CircleRate  
      
      > Hex是地图形状的基础构成单元，里面关联了Tile单元，Hex集合构成了Zone的形状，进而构成了整个地图的轮廓大体，此外还有空间换算辅助(候补放置点)，道具组寻路辅助(道具组的全连通)等作用    
      > - Hex的主要数据段为Pos，可配置数据段为控制Hex尺寸的TileSize(多少个Tile)  
      > - 将Hex视为图的节点，则Zone是一个子图，整个地图是由Zone子图构成的  
      > - 地图是个无向图，Zone子图是连通图(任意两点之间可互达)  
      > - Zone子图之间不一定是连通的，按配置信息Config设置联通  
      > - 为了保证Zone内全连通，Zone之间按需求联通，实现做法是：  
      > > 1. 先按配置将Zone的中心HexPos进行联通 [作为后续步骤的基础数据，拓展玩法如多层地图则在此数据下对下述步骤进行不同层次数据的执行]  
      > > 2. 可以对联通路径加噪声进行扰动，然后由各自的起点沿着连线用元胞生成的方式，在Zone的HexSize限制下交替的生成Hex的集合  
      > > 3. HexSize沿着已有Zone的集合外围随机扩充一个Hex生成，算法结束则Zone是个无环联通图，两个Zone相互接壤  
      > > 4. 根据配置按对应Zone的CircleRate对区域内的无环联通图进行加环  

      > Tile图生成  
      > - Tile的主要属性有Pos，归属Hex，归属Zone(Hex可能归属多个Zone混合情况)，状态(状态测试表[norm, blk, prot/road， visit, unit])  
      > - Tile阶段主要任务两个：初始化Tile的基础基础轮廓和State[norm, blk, prot/road]， 根据Hex信息和Tile实际轮廓统计出一些放置锚点(Hex顶点，边缘中点，中心点等的范围搜索后的有效点)   
      > - 初始化轮廓和基础State的实现：  
      > > 1. 按配置的TileSize初始TileMap，并根据生成的Hex图初始化有效的Tile集合(陆地)  
      > > 2. 统计Tile图的外轮廓，随机增加或腐蚀或增加，产生不规则表现  
      > > 3. 根据Hex联通关系，寻路出Tile通路标记prot
      > > 4. Tile统计Hex边界内轮廓，随机腐蚀增厚，并标记blk(状态测试表规定避开prot)  
      > > 5. 基础的norm和blk在这个阶段初始化完后面不再出现且逻辑简单直接blk覆盖norm，剩下的则可能不定次序出现即一个Tile进行State测试时旧State可能是其余任意状态
      > > 6. 测试的时候可能是按单个tile进行，也可能是按某个Tile集合(unit覆盖多个Tile)并按all条件进行测试
      > > 7. 测试通过后会存储到TileMap，可以直接覆盖，但如果按位并存则可以保存更多数据用于拓展规则数据依赖的支持
      > >   ||norm|blk|prot/road|visit|unit|
      > >   |---|---|---|---|---|---|
      > >   |norm||||||
      > >   |blk||||||
      > >   |prot/road|🆗||🆗|🆗||
      > >   |visit|🆗||🆗|||
      > >   |unit|🆗|🆗|||🆗|
      
      > - 放置锚点计算：  
      > > 1. 用Hex的空间转化公式(见Hex基础换算相关)转为世界坐标再转为Tile坐标，Tile按范围搜索区域内随机可用点作为候补锚点集  
      > > 2. 搜索是因为Hex换算后的点往往状态被设置为不可放置的状态  

      > 功能单元放置  
      > - 上述流程之后会得到带有基础state(norm, blk, prot)的Tile，Hex一些放置候补锚点  
      > - 按照配置权重和单元刷出公式(配置刷单元批次，对应批次参考权重，区域大小HexSize，TileSize决定单元组数和各单元组权重，再根据地形限制，单元候选列表)，迭代刷出任意个道具作为一个组  
      > - 按一定规则决定是否道具组能够放置，道具组覆盖范围的Tile测试是否全都通过，道具组是否与Hex中心能够联通(放置的过程会改变地图的State可能出现unit堵死旧道具组的情况，以及新的组被旧组影响刷在死胡同，为了避免则让每个道具组到保证在Hex内全连通)  
      > - 此外可能还有一些其他业务规则的拓展限制，全部通过则更新道具组的State和保证联通的通路prot状态到TileMap，测试并覆盖完所有单元组  
      > - 一些特殊业务比如主城，地洞，传送门，船坞，会优先放置，然后在prot中寻路得到road标记上去，再进行通用单元组放置逻辑[Mine，Edge，Empty]  
      > - 刷单元过程由于是数值估算和公式配置的，可能存在数值导致的失败情况，采用尝试上限设定进行抛弃或者转化来保底  
      > - 道具组放置的Hex中心联通检测保证了Zone内道具组都可达，但又缩小了寻路规模限制在Hex内，再由Hex的联通拓展到Zone，Hex的辅助分区作用用于性能优化思路  
 
      > 最后一个是根据blk范围和阻挡资源：
      > - 按地形类型进行阻挡资源的匹配，使得生成的阻挡过渡自然样式丰富(地貌过度问题)  
      
      > Config全局配置内容：  
      > > 轮廓腐蚀度
      > > Zone联通关系
      > > 刷宝策略
      > > 多层配置  
      
      > 实现方案尚存在问题：
      > > Zone联通关系成对生成，选中的Zone对的时序导致的一些不合理，先发育的会先挤占空间，后发育的会先发育好的Zone驱赶导致可能出现大环路  
      > > 复杂的Zone连通关系(一个区域有多个联通)或者Zone的HexSize配置可能导致生成失败，比如某个联通Zone较后被选中，且因为被先选中的邻接Zone先发育挤占了自己的发育空间导致发育失败(极端就是没发育就被包围了)
      > > 上述两个问题可能的改进是1.用维诺图而不是规整六边形(带来空间换算压力)，2.每个Zone与其余Zone根据size自适应的控制各自的分布位置的算法
      > > 地貌阻挡过度问题
      > > 超大规模地图生成问题...


    - 渲染TileMap                                
   
    - 寻路(两种策略)：
      > 单源单目标寻路:  
          每次点击都重新寻找一条路径，可能搜索范围小(极端情况会退化为全图)，但如果是高频操作则乘上频次的成本时间会上去
      
      > 单源多目标全图寻路:  
          从某个起点发出的到达全图的路径，起点变化或者环境变化则可能要重新寻路，满足前面两者稳定的条件下高频操作友好只需计算一次，但单次计算的成本会比单点寻路高  

      > 最小连通图：
          不等于寻路的结果，见prim与djstra的比较
      [寻路相关细节](寻路相关.md)
      
    - 性能  
      > 地图加载性能问题：  
      > 1. 算法实现层面：算法中的冗余循环，不合理性能消耗    
      > 2. 平台：脚本运行时的性能压力，C代码要快50-100倍  
      > 3. 加载策略：全动态加载(时间消耗)/全静态加载(容量压力计算：...)  
      
      > 载入地图后地图更新压力：  
      > 0. 地图规模：250*250，极限算10^6，如果全图刷新需要0.1s，则依次遍历的情况下单位单元的时间片是10^(-7)级别即0.1us  
      > 1. 算法优化：分块加载，刷新策略(单目标多次寻路，单源全图寻路)  
      > 2. 平台：计算和更新迁移到C  
   
    - blender
   
  - C交互
 
  - 翻译
 
  - 工具
     - 自动打包提交
       
- 定时器

- 资源

- 打包相关

- 在线更新  
  > **逻辑更新**： python特性实现  
  > 服务端不清楚，但因为服务端也是py开发环境原理应该也差不多  
  > 客户端在线更新：针对业务逻辑，改动较小的情况，重写对应的方法，类，然后在一个上下文直接注入到对应的实例对象(比如全局单例对象)覆盖原有方法，或者注入模块覆盖原有全局方法，或者直接覆盖模块或者成员对象的某些成员(一般是一些常量定义)，然后将自测完毕的代码文本由服务器发送给登录的指定用户，通过py的exec/eval特性生效  
  > 注意内容：  
  > - 起效时机：在线更新的生效时机是在用户与服务器进行联网交互之后，所以登录之前的内容(登录界面以及之前的引导动画等的逻辑无法在线更新)  
  > - 规范：小范围，如果设计的改动逻辑短太多比如一个很长的函数中间的内容修改，则酌情考虑是否更新(广播是占用服务端带宽的，且越长错误概率越高)，最好是头尾改动可以用类似与装饰器的切面思想拦截后判断部分条件特殊处理其余则执行原逻辑  
  > - import：重写的方法内直接import了方法题外import的模块的情况，重写的时候需要在函数题内import一遍，因为函数的定义是与模块有关的(py的顶层单位是模块，import的内容存在模块的global空间，函数对象定义的时候会用帧对象的全局空间就是直接引用这个global空间)，而重写的在线跟新函数是在另一个修补模块定义的，他无法直接在原函数内引用到原函数归属的模块，必须显式的再import一遍(但也不再该修补模块下import，防止多个在线更新冗余在一个模块下: https://fasionchan.com/python-source/function-mechanism/function-object/)  
  > - 引用链：不管是模块下的一些常量宏定义的修改，还是模块下的定义对象(类，函数)的修改，如果其他模块是from ModX import xxx 对应内容，则需要显式的执行一下ModX.xxx的重定向，因为ModX的内容的修改不会自动同步到引用ModX的地方，会导致旧内容被其他地方依旧引用住  
  > - 循环生效: 在没关闭游戏的情况下断线重登的情况或者自己断开连接重新登录的情况，在线更新逻辑会被执行多次，要防止模块重复生效后逻辑错乱(比如修改结果随着调用次数的堆叠生效:return + X，或者递归调用自己死循环：条件分支的时候条用自己但执行过一遍替换后原函数就已经是替换后的函数了然后一直符合条件分支一旦执行会死循环栈溢出)，避免就是重新定义修补方法的时候判断一下原函数存在否不存在就吧原函数缓存起来改别名，然后以此为标记只重定义一次且对原函数的调用用别名  

  > **资源更新**：  
  > **市面方案**:
  > LUA方案/ILRuntime方案/...
  >  - LUA方案就是cocos+py结构，对UnityEngine和C#进行LUA的导出支持LUA和C#的交互(C和python交互方案),然后业务就可以支持由LUA进行开发了，自然基于LUA的业务就可以使用上LUA的反射功能，LUA由于是解释型脚本语言无平台限制  
  >  - C#是强类型语言会产生中间代码IL然后再编译为汇编(本身无法跨平台)，但C#本身也有反射讲道理也可以直接用反射热更(将项目框架是分为主体框架(不变)和业务模块(被主体反射载入调用)实现热更)，但又IOS平台对C#的反射进行了限制导致无法全平台，ILRuntime在中间代码IL下手可能是绕开了IOS的反射限制吧，将热更内容打成dll用内置模块从中提取IL信息并用内虚拟机进行执行**(但还是不知道ILRuntime怎么绕开的..) **  
  >  - https://cloud.tencent.com/developer/article/2239496  

- 代码管理

- 上线相关

- 性能优化

- 属性同步

- GC

渲染知识应用：

- 渲染相关应用
  - 阴影,染色,半透,LUT

- 图集

- dc

- 合批

- 渲染管线

- 压缩算法：pvrt

- 对象池

- 场景绘制逻辑

其他：
uml：
https://blog.csdn.net/qq_39847278/article/details/140821766

正则

SIMT并行加速

---
