---
2024.11.18  
[对照面经](https://www.nowcoder.com/discuss/596064413442949120)

#### 项目架构:
公司lw引擎+公共代码+项目代码  

引擎提供游戏的基础共功能模型,特效,资源加载,场景,摄像机,光照声音,网络等基础功能  

公共进行了一些各项目共用常用的模块封装: 登录,网关,UI封装,屏蔽字,防成谜,实名认证,邮箱,充值等  

项目代码整体情况:  

1.状态同步
  - [状态同步/帧同步](同步模式.md)
  通过协议的方式与服务端拟定协议事务,进行状态同步

2.代码框架:MVC,ECS,ECGame
  - [MVC,MVP,MVVP](项目框架.md#mvcmvpmvvm)  
    大部分业务,包括UI模块都是用MVC的形式组织起来,不好的一点是出现了模块嵌套,但并非mvc本身问题,mvc本身可能存在没有必要存在view或者model的情况和ctrl臃肿
  - [ECS](项目框架.md#ecs)  
    战斗相关的业务用ECS进行改版尝试,服务端是用的ECS,为了与服务端同步好进行属性同步,同时方便的卸载加载组件,以及代码结构简单,但调试还不太方便
    
3.用到的设计模式：  
  - [单例](设计模式.md)  
  - [观察者](设计模式.md)  
  - [策略模式](设计模式.md)  
  - [指令模式](设计模式.md)

4.代码管理:
  svn,传统,co,update,reverse,merge,commit
  工具少量git(fetch,pull,push,merge,commit):  
  - 云效ci/cd蓝图  

5.开发流程:
  - 项目自行检出引擎工程进行编译(bat执行Cmake,ide编译工程,ide版本要求),编译过程中可以配置一些操作启用禁用,自定义拓展引擎功能(在引擎c层上开发,一般是效率考虑)  
  
  - 专门的公共代码检出和更新工具,检查版本和依赖进行公告脚本代码更新
  
  - 各种编辑器(没有集中):  
    数据编辑器(导表): 做了一些封装,用他的规则就可以对数据文件自定义解析,一般解析为py文件格式是字典等可以直接加载数据类型或者类化为对象再自定义一些工厂函数使用
    
    UI编辑器: 记录UI控件布局为配置文件,再解析为py的指令文件,继承UI对象的时候用指定文件路径名的方式执行布局指令集来初始化UI,将存粹UI布局隐藏独立开后又方便的在下方可以编写view相关的操作逻辑且还内聚为view 

    法术编辑器: 针对操作的都是引擎基础节点的公共方法,比如播动画,节点生命周期管理,空间操作,吧这些操作抽象为时间轴,时间轴的集合就是操作的集合,时间轴的时序就是法术播放的时序逻辑,附带condition, 发信号等控制指令就可以编排与外界的交互,对应的法术配置序列文件可以静态话下来以及需要的时候切换和维护,没有用状态机  

    地图编辑器: 2d瓦片地图,在对应的瓦片上放置单位就行,后续增加了一些预制组合之类;随机地图则只需要编辑关键点,联通关系,资源生成模板;  

    资源编辑器: 主要是编辑特效,gfx,mod, 例子发射器(基础元素面片,广告牌等的动画,生命周期,运动轨迹控制的组合),针对模型的材质纹理的周期性调整(UV动画)  
  
  - ci/cd平台: 内外网隔离  
    ci负责一些资源批处理工作,如代码文件化,资源检查(图片清理,模型大小,贴图缺失),资源自动加工(生成索引文件,导表到处)等,依旧处于内网  

    cd是将项目按固定格式组织后用提供的打包脚本吧资源,脚本打包加密为特定文件或者目录后部署在指定的域名下面,然后经过一系列校验手段(文件发布审核,md5+下载url的索引文件发布审核)进行发布到外网,游戏/游戏平台内置会去对比最新的索引文件,发现差异则根据索引内容引导下载更新,用于整包/补丁/工具文件的外网发布

---
#### 主要模块:  
---
##### 通信  
  ecgame框架:  
  1.主要是封装了与服务端的通信功能,用dll的形式暴露接口给客户端使用
  2.服务器还支持了一个把部分逻辑集成到客户端的功能(打包为脚本文件),他们会通过ci吧他们一部分逻辑(不涉及安全的逻辑,如buff计算推演逻辑)集成到客户端,然后两边公用一份代码,两端都通过协议交互与之交互;共用逻辑,减轻服务端压力.
  通信的形势是拟定协议的方式,给要通信事务进行编号,拟定事务携带的参数类型,数量,用一份特定格式的协议文件进行记录,两端同步每次加新协议就要约定好后同步解析  
  解析出来的是对应事务的py函数,函数做的内容就是将参数压包和解包为协议规定格式的字节流,上层直接调用业务py函数,隐藏了这些字节流压解细节,然后给dll字节流后会用socket进行通信([socket](知识点misc.md)❓)自己实践过一次,但查乱码之类麻烦,后面用引擎封装的([大小端](知识点misc.md#大小端)❓)

---
##### 基础内容  
  - 特效  
    gfx，mod，叠加特效(❓),指令模式(❓)+组合模式  
    特效有一份完整的游戏资源目录：tex，model，mod/gfx嵌套？？
    gfx是粒子特效等的组合和对外封装
    mod是结合模型的进一步封装，可以指配到具体模型的具体动作的特效，组合了gfx和子mod
  
  - 模型：  
    1. 前期的模型规范，参考其他项目组和主观感受，原先2w顶点，面数(❓),定制依据(❓),后面定制为(❓)，一些分析工具的开发，模型性能上限测试，同屏200个不掉帧
    2. 角色对象的封装：
       ![image](https://github.com/user-attachments/assets/122a4600-1c15-4085-b89f-59e4ac7977a2)  
      
  - UI系统/管理/优化/携程应用
    - 分辨率适配UI  
    - 2^n尺寸  
    - 响应逻辑链条  
 
  - 场景管理  
    - 状态机  
    - 流程  

  - 战斗:
    六边形棋盘格回合战旗
    - 场景管理(区域事件)：
      1. 场景的生命周期管理：场景资源预加载，入场时间提前到游戏开始，实现战场秒加载；或者用分帧实现排列展开程序的入场展现方式，最终用了前者；异步加载表现不好；
      2. 区域事件：比较简单，主要是一些与逻辑位置相关的事件机制，服务端也有类似逻辑，服务端的自行实现后只通知客户端表现结果，比如陷阱伤害；客户端的仅用于客户端表现的区域事件，不如靠近建筑遮挡视野后建筑半透

    - 框架和数据结构：  
      状态同步+指令模式（所有操作都是指令，用队列进行管理）+ECS：  
      1.在客户端视角，大部分指令都有客户发起和服务端广播表现两部分，少量不需要客户端发起行为(服务器逻辑驱动)：  
         等待输入指令，移动指令，普攻指令，魔法/技能指令，防御指令  
      2.客户端是行为收集就是简单的协议通知服务器，会有一些检查操作比如操作范围越界，目标选取逻辑等  
      3.客户端对服务端回复指令进行演绎，所有回复结果在服务器统一计算各端只是演绎结果可以保证一致性，也方便排查问题(结果不一致则确定是服务器问题还是单端客户端，客户端是某个客户端还是全都，还是网络问题)  
      
    - UML：
      1.战斗实例上下文
      2.各种系统：
      3.各种组件：
      4.表现指令队列和指令对象
      
    - 表现指令队列：  
      指令队列的逻辑本身简单，顺序执行指令，指令里面获取上下文和操作目标(一般是角色或者空节点)，但有一些情况：  
      > 1. 嵌套指令：  
        召唤魔法————这类魔法都有一个通用的施法动作表现指令，但在表现一半的时候需要开始召唤逻辑即入场指令，但指令是顺序串行(服务端是线性发送，表现时机是客户端动态计算的，对于服务端而言不知道什么表现上的嵌套逻辑，只知道是两个指令，客户端数据结构也是线性队列)  
        不改变指令结构，那只能通过更复杂的指令组合来描述这个业务，比如吧通用施法指令拆解为两块，前摇指令和后摇指令，然后通过前摇+Spawn(入场+后摇)的方式来实现，但这样服务端的指令组织变复杂需要关心到客户端的表现细节(为了表现拆分也在指令组织上进行拆分)，客户端需要对所有的通用施法表现(每个角色都有自己的施法表现)进行拆分，动画资源在施法这一个上*3且有工作量  
        所以对指令进行扩展支持子嵌套子指令，约定主次指令的顺序比如先发主指令再子指令，再约定指令搜索规则比如子指令自动搜索最近的一个目标类型指令进行嵌套，就可以在主指令执行生命周期内执行其他指令，具体时序可以靠信号机制触发比如动画k帧触发信号，特定信号进行子指令执行；思路类似于指令组  
      > 2. 多段法术：  
      简单的可以直接服务端发送多个指令，首位相接即可，但指令的串行就会在每个指令表现完之后才进行下一个，而很多时候多段表现衔接是不等一个指令完全执行完就开始下一个表现，这种情况将多段衔接的逻辑下沉的魔法表现系统，里面也是个指令模式各个表现是单独的指令且可以组织为文件，组织为首段法术文件(攻击，关联，受击)和链接法术表现(关联，受击)，然后就是在一个法术指令内串联这些法术文件播放；法术指令的拆分不放到上层业务是因为上层指令需要与服务端同步，上移意味着服务端或者客户端业务需要关心到表现细节
      > 3. 事务/指令合并：
      有些指令类型是高频重复出现，会带来重复计算：比如某个buff导致的多个属性更新，其实是一个事务，但由于属性更新协议粒度问题导致需要多个协议来通知触发多次更新逻辑，可以通过指令缓存，然后识别可合并指令，在执行前执行一次指令合并来实现(类似于cocos中自动合批渲染逻辑)，具体实现上是处理为连续属性跟新指令才自动合批，不连续的属性更新指令有时候表现就是要被其他指令隔断开的：比如受伤扣血后又触发补血，中间得先表现受伤扣血，在恢复动画，然后再回血扣字
      > 4. 防阻塞：  
      可能指令实现有bug，然后一直阻塞住整个队列执行(比如没正常释放)，需要一些超时保底自动推进机制  
      > 5. 乱序：  
      比如前期客户端有自己插wait()的操作，如果逻辑异常在处理一个正常的wait0()里面先插入了一个客户端wait1()，然后会收到服务器对第一个wait0()的表现act0()但被wait1()卡住没表现,且第一个wait0()没有结束回合还能继续操作又收到第二个wait2(),队列为[wait1,act0,wait2],这个时候再操作使用了wait1()和执行了后续的act0()，但服务端会以为这是wait2()执行又给后续act1()，队列[wait2,act2],实际表现就是点第一下客户端没反应，第二下的时候执行了第一下的表现，点第三下的时候执行第一段到第二段的表现，这跟用户操作的预期是不一样的，而且服务端也会错误的收到第三个wait的输入；处理办法可以是给cmd都加编号这样指令执行的时候就可以进行一些异常检查；项目的处理是禁止这种乱序的源头比如不允许客户端插入wait，还有加一些指令队列实时打印进行调试  

    - 技能管线：预测机制：  
      ![a5a6e588c9efb82091fbf137bfa9b01](https://github.com/user-attachments/assets/110f5e4c-ff0e-4e9b-8d10-b08ca412c3a1)  
      https://weibo.com/ttarticle/p/show?id=2309404808077663928613  
       > - 分两次请求发起技能和命中结算而不一次，在即时游戏中由于同步的滞后原因，客户端在对当前同步内容做出回应的时候，无法预测到有没有当前世界的更新内容(会影响客户端做出的操作的结果的内容)正在路上，如果一次技能请求同时请求是否能发起和命中程度，那返回的结果可能没命中，命中且与预测部位一致，命中但由于有操作信息未更新过来所以命中信息有偏差，且命中细节有时候并不在服务器(比如精确到模型的部位)，即这次请求里面包含来太多情况粒度不一致，收到回包即使与预测可释放一致，也还需要重新计算名字情况并发起请求
       > - 讨论表现时间足够长足够回包到来的情况，分两次请求且两次都带预变现，那第二个请求的预测误差更大(基于第一个)，完全可以借用第一个预测的表现时间，在收到第一个回复排除一些情况和同步了更新的信息(比如不可释放)后马上进行第二个命中请求，并将请求信息缓存，等真正要执行命中请求的时候直接回复  
       > - 如果用中间层，那类似于热插拔结构，与没有中间层对接上没差别，但中间层在透明化的同时帮忙进行缓存数据和做一些小动作  
       > - 如果是回合游戏，在一个回合的逻辑时间长度上，不可能有任何他端操作会改变服务器世界数据导致本端操作逻辑过期而导致表现误差，更不用考虑延时这种级别的脏数据问题  
      
    - ECS：  
      ![bdf08114f88d142039b20c5dab0cf45](https://github.com/user-attachments/assets/d4cb4593-2f31-4e14-8597-637ea7c97c35)
      全局的事件系统作为通信手段，低耦合关联Sys和Com
      大部分通信发生在Com和Sys的切面时机: 创建销毁更新
      逐帧驱动框架运行，也可以进行指令控制(ECS框架级别的指令)比如用上下文管理实现属性更新的合并  
      
    - 魔法：
      针对表现逻辑的指令系统，与表现相关的操作都封装为指令，在系统内用代理模式操作角色代理，然后用时间轴以及蓝图的形式提供给编辑工作者精细的支持编辑角色的移动，动画帧级别的表现，外部对系统的交互用传入参数的方式传入角色对象和一些动态数据如位置，系统对外部用事件的方式进行通知和携带参数比如事件名称，对应的特定事件参
      ![99f8a3cebb32de1ef56ad922d113aa3](https://github.com/user-attachments/assets/e144b09d-197c-435b-82dc-8e42e1f9af55)
      
    - 加速：
      
    - 六边形地图：
      ![05574be53ea45aaba771739c6b7d5b0](https://github.com/user-attachments/assets/d71ad69c-2fd4-4ea7-893f-df91ea7c6681) 
      轴坐标系/立方体坐标系qrs   
      > 1. 向量运算:(基坐标有所不一样),  $\color{#ff0000}{浮点向量的取整(round(max(axial))修正)}$ ,向量和像素互换  
      > 2. $\color{red}{坐标转换}$ ：axial/cube <--> offset  
      > 3. 采样: DDA, freshham??    
      > 4. 范围：max(q, r, s) == dist, circle遍历，max/min求交集，Rotate(为同dist的圈中rotate，六边形圈为基点)  
      > 5. $\color{red}{寻路}$ ：无差别，huristic: max(q)+max(r)  
      > 6. 射线检测：breshham 🛠️，https://www.redblobgames.com/articles/visibility/(碰撞点/边排序后按角度检测碰撞) 🛠️

      https://www.redblobgames.com/grids/hexagons/#map-storage  

      
    - 录像：  
      一般是帧同步记录操作，或者状态同步记录状态切片文件(精度问题和文件储存占用)  
      客户端的录像：数据更新都是通过协议来的，所以即使没有用帧同步的方式，也不用快照，记录协议来实现录像(相当于服务端假数据)  
      有些特殊情形要处理，有些服务端指令回来后会导致客户端阻塞等待，然后需要客户端操作来解锁并回复(即整个回合的正常推进需要客户端操作环节)，这个时候记录只会记录回复协议不会记录协议之上的任何客户端操作:  
      > 1. 统计这种客户端操作，支持对这些全局阻塞操作的跳过开关
      > 2. 需要客户端协议演绎之前绑定一些专门测试用的客户端操作模拟(不要真的操作不然操作本身也会发协议)
      > 3. 替换客户端指令，重定向走真正的客户端操作(比较难，可能设计UI操作,比如鼠标如何拖拽或者点击某些地方)
      
      目前遇到的就只有等待输入会阻塞游戏一个情况，用了方案2，暂时只是用于排查bug工具
      
    - 观战：
      状态同步，直接用世界数据重建场景，后续接收广播即可实现
      
    - 联机：

     - 行为树：
   
    - AI：
   
  - 地图
    主要内容分为四块：生成，调试, 渲染，更新，
    - 随机地图生成：     
      [H4实现细节](随机地图PCG.md#h4随机地图细节)  
      > 需求：项目地图的需求是实时生成的随机地图TileMap类型，在具有随机性的同时又要可配置影响地图随机结果使其具有一定符合预期的特征，且支持复现和调试：  
      > > 一类是地形控制：比如控制区域的数目和大小，区域之间的相对位置和联通关系，区域内阻挡分布情况   
      > > 一类是数值控制相关：功能单元刷出情况，道具NPC的价值区间和数目的把控，(有一个公式详见细节)  
      > 
      > 提供一个全局配置的上下文(一开始是类似Excel的工具，后面制作了可视化的边界工具，**蓝图**不说...)，策划配置生成原点(区域)，连通性，数值等上述配置项  
      > 确定**随机种子**, 然后根据**元胞自动机**算法由源开始生长，利用**六边形网格**作为辅助层，用**寻路算法**保证联通，生长出六边形区域确定区域轮廓，联通关系等，再往有效的六边形中生成Tile数据，阻挡分布，资源分布,全都根据随机种子进行    
      > > 元胞自动机：模拟细胞生长，由已存在的元胞按一致的策略进行运算更新现有的全部元胞项目是用来不断生长元胞扩充区域(沿边随机生长)，和边缘轮廓的腐蚀随机风格化  
      > > 1. 用元胞自动机是为了让地形随机效果具有可配置性，在项目中有生长源点  
      > > 2. 同时也是项目需求希望有隔间又不希望功能单位挨得太近又兼顾随机效果，这种生长思路与泊松圆盘算法或者米歇尔最佳候选类似  
      > > 六边形的作用两个：1. 降低生成压力，分层计算的思路，2. 方便的空间换算，3. 比起方形组合出来的轮廓更平滑不会有明显的直角轮廓   
      > > 1. 地图最终是TileMap，但是TileMap数据的产生需要一些诸如：高频的进行长距离寻路比如保证两个主城之间的连通性主城分布很远，以及整个游戏中道具都是可以访问的不可能求所有道具的全连通图来保证合法性，且是实时生成性能要求更苛刻，所以通过更小规模的六边形网格的连通性来代替Tile级别的连通性，Hex内部的Tile是全连通(用Hex的中心Tile作为基点，每个道具只要保证跟中心Tile是联通的就能保证全图联通)，两个Hex之间联通则两个Hex内的Tile就全连通，Hex图也是全连通的就是保证了所有Tile要保证全图联通性只需要保证Hex规模的Tile的连通性即可，项目中Hex约容纳15*15=256Tile，则左下到右上的寻路性能节约256倍，全图联通则退化为Hex内Tile规模的寻路    
      > > 2. 一些锚点数据的快速计算，元胞风格化后轮廓和内陆形状不可控很难进行描述从而开展配置，用六边形的顶点作为基点然后根据基点进行扫描周围Tile，六边形是规则图形空间换算很方便  
      > 高频率的进行寻路来保证联通，Hex的寻路，Tile的寻路，限制寻路规模，然后用标记互斥的的方式来进行单元摆放(详见细节)  
      > 最后整理输出数据给加载和渲染  
      > 相关算法： 随机种子，寻路，元胞生成，分层计算，坐标转换  

      模块代码结构：  
      > OOP思路：  
      > > 主要类有Zone(存储一些数据输入输出数据和下层的归属信息)，Hex(轮廓相关和一些辅助运算)，Tile(属性数据)，Util(寻路，空间换算)  
      > > 大框架是线性结构，整个地图生成管线清晰没有图状的复杂关系  
      > > 每个模块内是组合模式，每个模块里面的逻辑都是一种依赖当前模块数据的数据处理和输出到当前模块，采用策略模式将加工逻辑封装成各种策略，基于组合模式可以方便的增加或者减少策略以及扩展策略(开闭原则)，这一点为后期编辑器拓展预留了代码结构  
      >
      > ECS思路(待动手)：  
      > > OOP模块之间有数据依赖，有些模块提供的是辅助数据，其实可以直接面向TileMap的，保证每个处理逻辑的输入输出一致默认空Tile，所有的数据都是Entity，Tile的数据段是一个Component，其他任何辅助数据/中间数据是其他Component，  
      > > 每种Component都有自己处理的Sys(策略)，开闭原则的体现或者说编辑器上拓展时就是支持对应的Sys和Component，也是组件形式，消除了大框架的结构配置更加灵活，这种数据密集操作的ESC有优势(集中性原理，但没实践没测试，py估计也体现不出来)  
      > > 缺点是不直观[ECS细节](项目框架.md#ecs)  
 
    - 调试经验：
      调试支持开发时间与业务开发几乎持平，有几乎一套框架：复现机制，校验机制，异步执行，断点载入，可视化过程，远程自动测试，   
      > 调试难点例子：(有些要动手实验下看看有没有坑)  
      > 1. 地图复现：  
      > > - 其他配置不变的情况下或者自己开发过程中，只要固定随机种子就能复现地图  
      > > - 但影响随机结果的还有配置文件，算法版本，所以每次生成地图都会记录一份种子，配置和版本，算法版本文件以及各阶段的一个md5标记和生成结果的md5用于校验(md5的检测对象要一致，所以md5检测方案的版本也要匹配)  
      > > - 在自己调试的过程中可能出现想到的都匹配了但还是生成不一致，则对比各阶段md5标记找出差一点缩小范围  **(动手)**  
      > > - 如果md5匹配不上可能是浮点数平台问题，以及服务端数据参与，比如某些数据只是占位符但是开发的时候不小心出bug存储用了服务端真实返回的数据的时候  
      > 
      > 2. 问题环节定位：**(动手)**  
      > > - 有些异常出在比较靠后的环节，每次重新调试从头来比较低效， 代码重构为策略模式后可以按模块和策略为切面，缓存运行结果然后下次直接读取缓存  
      > > - 装饰器模式，将被装饰策略和模块对象序列化为文件    
      > > - 同样用装饰器模式判别是否存在文件，存在则直接从文件反序列化为对象  
      > > - 可以支持回退  
      > > - 有个前提就是有异步执行机制   
      > 
      > 3. 数据规模的干扰(寻路异常):  
      > > - 寻路结果不一致或者异常断路等，调试的时候直接打印或者断点在逻辑里面往往会被大规模触发，难以辨别出问题的点，需要不断细化出发调试条件，常见如范围限制，一些状态更改监听，策略(cb注入)或者装饰器的形式注入限制  
      > > - 可视化过程，显式更直观发现那一步开始出现差异  
      > > - 需要异步执行机制  
      > 
      > 4. 中断调试：**(UML或者大致实现结构)**  
      > > - py协程重构，生成过程都是协程式的(生成器)，可以在任意逻辑入口处注入到异步过程实现中断  
      > > - 协程包装器 **(Py3协程练手)** ，每个协程逻辑都有一个返回对象，里面的标记通知是执行玩还是中断处以及获取中断返回数据，中断则继续上抛，核心逻辑是层层嵌套的while，用于回复执行权的时候继续从各层级中断处往下执行  
      > > - 支持全局开关区分调试环境和生产环境   
      >
      > 5. 可视化过程  
      > 
      > 6. 自动测试  
      > > 测试分两类，报错类型和非报错内容异常类型  
      > > 部署到云校持续集成平台，自动不间断测试，尤其是每次配置和算法版本发生改动  
      > > 对于会报错类型，一些隐晦的条件和隐晦的bug导致人为比较难发现，则可以捕获异常后记录复现文件  
      > > 对于不会报错的类型，比如配置的异常导致数值出现异常，算法的细微差别导致了数值的异常，或者生成地图失败的情况  
      > > 前两者可以通过统计生成数据，策划根据公式给出数值范围进行判别，异常波动则推送观察  
      > > 地形相关的则可以出单独的测试用例统计地形结果合法性，比如统计所有建筑的分布和周围的地形情况判断是否有不可达情况  
      > 
      > 7. 隔离与测试单元  
      > > 上面的断点载入基础上，有些修改要保证改完单元模块输入输出一致性，比如一些不合理或者冗余的跨模块数据依赖重构，模块拆分等

      内存泄漏
 
      提供的工具：  
      imgui + pyqt + 内置显示  
      > 1. 生成过程可视化 + 类似断点调试工具
      > 2. 复现工具  
      > 3. workbench(云校)  
      > 4. 可视化编辑器+数据统计+加工器：操作配置（整个模块独立，可以直接跨平台）  
      > 5. 蓝图：操作逻辑的 **(动手或者细化)**  
    
    - 思路来源：  
      > 市面地图类型：平面像素蒙版地图，格子地图，网格地图，箱庭地图(暗黑), 北境，群星，泰拉，养恐龙那个  
      地图分类：静态地图(专门的资源制作团队(策划，美术，或者两者配合)出的静态资源)，全动态随机地图(饥荒，H4)，折中(一些静态资源+一些动态逻辑堆叠)  
      参考：英雄之时，H3地图论文(❓❓)，redblob  
      相关知识：  
      > 维诺图  
      > 泊松圆盘，米切尔最佳候选  
      > [Noice相关](随机地图PCG.md#噪声知识)  
      
      其他实现思路：  
      > 为什么不用noice：
      > 候选思路与米切尔最佳候选对比：
      > 
      > 8. 
      > 9. 重构过程：数据依赖梳理，调试，随机种子复现逻辑，util，业务扩展性，delegate，导表配置模板复用，可视化编辑器  
      > 10. 实现方案尚存在问题： 
      > > Zone联通关系成对生成，选中的Zone对的时序导致的一些不合理，先发育的会先挤占空间，后发育的会先发育好的Zone驱赶导致可能出现大环路  
      > > 复杂的Zone连通关系(一个区域有多个联通)或者Zone的HexSize配置可能导致生成失败，比如某个联通Zone较后被选中，且因为被先选中的邻接Zone先发育挤占了自己的发育空间导致发育失败(极端就是没发育就被包围了)  
      > > 上述两个问题可能的改进是1.用维诺图而不是规整六边形(带来空间换算压力)，2.每个Zone与其余Zone根据size自适应的控制各自的分布位置的算法  
      > > 地貌阻挡过度问题  
      > > 超大规模地图生成问题...  

    - 渲染TileMap
      - 1. TileMap包边知识  

      - 2. 基础方案：TileMap内部实心，边缘包边，原生的直接跟Tile一对一实例化对象，但有性能瓶颈：
        1. 大量Tile实例即使进入渲染管线后视口外的会被剔除(没有遮挡剔除的话会进入顶点着色器处理)，但引擎层面还有脚本层面还是要维持这些对象的，引擎层面节点树还会更新(空间状态)，初始化也明显掉帧
        2. 渲染管线里面的这些Tile逻辑简单就是采样，可能被动态合批了，但也可以直接离线合批(一个节点搞定)
        3. 纹理重复度问题，可以用一张较大的**边缘自拼接**底图纹理(1024*1024)，然后直接采样设置为重复就能有不错的纹理效果

      - 3. 实现方案(加了性能优化和渲染相关的方案)：
        1. BG和内部TileMap + 边缘包边装饰，内部不进行TileMap的纹理映射，只有边缘根据周围9格选择不同的边缘纹理进行映射
        2. 为了简单分层级绘制：不同类型区域每个区域独立层次，包边独立层级，背景海水独立层级
        3. 每层只用一个与地图等大UI节点
        4. 通过shader自行采样绘制在UI节点上,主要是纹理的重复平铺和包边纹理的合图查找
        5. 渲染细节见下面渲染相关详述
 
      - 4. 阻挡样式丰富化方案
        1. 阻挡/装饰也都是分层的，都基于正交摄像机
        2. 装饰直接在BG层之上单独一层绘制: 装饰纹理在平面随机偏移组合后离屏渲染得到纹理，也可以线下预先生成
        3. 阻挡单元开始的分层纳入了Z空间，用Z深度来区分层叠效果，下盖上，左盖右

    
    - 加载和更新
      地图同步
      联机地图
      八叉树  
      C++  
      分块寻路                            
      
    - 地图性能问题
        [细节见](性能优化.md)  
        > 地图生成性能问题：  
        > 1. 算法实现层面：算法中的冗余循环，不合理性能消耗    
        > 2. 平台：脚本运行时的性能压力，C代码要快50-100倍  
        > 3. 加载策略：全动态加载(时间消耗)/全静态加载(容量压力计算：...)
        > 4. 联机地图同步  
        
        > 载入地图后地图更新压力：  
        > 0. 地图规模：250*250，极限算10^6，如果全图刷新需要0.1s，则依次遍历的情况下单位单元的时间片是10^(-7)级别即0.1us  
        > 1. 算法优化：分块加载，刷新策略(单目标多次寻路，单源全图寻路)  
        > 2. 平台：计算和更新迁移到C  
   
    - 地图中的寻路(两种策略)：  
      > 单源单目标寻路:  
          每次点击都重新寻找一条路径，可能搜索范围小(极端情况会退化为全图)，但如果是高频操作则乘上频次的成本时间会上去  
      
      > 单源多目标全图寻路:  
          从某个起点发出的到达全图的路径，起点变化或者环境变化则可能要重新寻路，满足前面两者稳定的条件下高频操作友好只需计算一次，但单次计算的成本会比单点寻路高  

      > 最小连通图：  
          不等于寻路的结果，见prim与djstra的比较  
      [寻路相关细节](寻路相关.md)  
    
    - 成果：
      实时生成20s...  
      上线项目使用中，被纳入公共组，被其他项目使用，独立开发方便的移植  
      拓展为3d地图  
   
    - 进阶方向：blender  
   
  - C交互
 
  - 翻译
 
  - 工具
     - 自动打包提交
       
- 定时器

- 协程  

- 资源

- 打包相关

- 在线更新  
  > **逻辑更新**： python特性实现  
  > 服务端不清楚，但因为服务端也是py开发环境原理应该也差不多  
  > 客户端在线更新：针对业务逻辑，改动较小的情况，重写对应的方法，类，然后在一个上下文直接注入到对应的实例对象(比如全局单例对象)覆盖原有方法，或者注入模块覆盖原有全局方法，或者直接覆盖模块或者成员对象的某些成员(一般是一些常量定义)，然后将自测完毕的代码文本由服务器发送给登录的指定用户，通过py的exec/eval特性生效  
  > 注意内容：  
  > - 起效时机：在线更新的生效时机是在用户与服务器进行联网交互之后，所以登录之前的内容(登录界面以及之前的引导动画等的逻辑无法在线更新)  
  > - 规范：小范围，如果设计的改动逻辑短太多比如一个很长的函数中间的内容修改，则酌情考虑是否更新(广播是占用服务端带宽的，且越长错误概率越高)，最好是头尾改动可以用类似与装饰器的切面思想拦截后判断部分条件特殊处理其余则执行原逻辑  
  > - import：重写的方法内直接import了方法题外import的模块的情况，重写的时候需要在函数题内import一遍，因为函数的定义是与模块有关的(py的顶层单位是模块，import的内容存在模块的global空间，函数对象定义的时候会用帧对象的全局空间就是直接引用这个global空间)，而重写的在线跟新函数是在另一个修补模块定义的，他无法直接在原函数内引用到原函数归属的模块，必须显式的再import一遍(但也不再该修补模块下import，防止多个在线更新冗余在一个模块下: https://fasionchan.com/python-source/function-mechanism/function-object/)  
  > - 引用链：不管是模块下的一些常量宏定义的修改，还是模块下的定义对象(类，函数)的修改，如果其他模块是from ModX import xxx 对应内容，则需要显式的执行一下ModX.xxx的重定向，因为ModX的内容的修改不会自动同步到引用ModX的地方，会导致旧内容被其他地方依旧引用住  
  > - 循环生效: 在没关闭游戏的情况下断线重登的情况或者自己断开连接重新登录的情况，在线更新逻辑会被执行多次，要防止模块重复生效后逻辑错乱(比如修改结果随着调用次数的堆叠生效:return + X，或者递归调用自己死循环：条件分支的时候条用自己但执行过一遍替换后原函数就已经是替换后的函数了然后一直符合条件分支一旦执行会死循环栈溢出)，避免就是重新定义修补方法的时候判断一下原函数存在否不存在就吧原函数缓存起来改别名，然后以此为标记只重定义一次且对原函数的调用用别名  

  > **资源更新**：  
  > **市面方案**:
  > LUA方案/ILRuntime方案/...
  >  - LUA方案就是cocos+py结构，对UnityEngine和C#进行LUA的导出支持LUA和C#的交互(C和python交互方案),然后业务就可以支持由LUA进行开发了，自然基于LUA的业务就可以使用上LUA的反射功能，LUA由于是解释型脚本语言无平台限制  
  >  - C#是强类型语言会产生中间代码IL然后再编译为汇编(本身无法跨平台)，但C#本身也有反射讲道理也可以直接用反射热更(将项目框架是分为主体框架(不变)和业务模块(被主体反射载入调用)实现热更)，但又IOS平台对C#的反射进行了限制导致无法全平台，ILRuntime在中间代码IL下手可能是绕开了IOS的反射限制吧，将热更内容打成dll用内置模块从中提取IL信息并用内虚拟机进行执行**(但还是不知道ILRuntime怎么绕开的..) **  
  >  - https://cloud.tencent.com/developer/article/2239496  

- 代码管理  

- 上线相关  

- 性能优化  
  - 性能差的表现：卡顿(怎么定义)，帧率低，网络时延，  
    - 归类：  
      - 逻辑类：  
      - 业务实现异常：递归终止条件异常，   
      - 业务优化：逻辑优化(冗余循环)，  
      - 实现技巧：对象池， 分帧/分页，懒加载， 预加载，异步，合图，高频调用迁移c+，分阶段生成并组合          
      - 资源类：  
      - 
      - 性能瓶颈：  
      - 平台：C+/Py  
      - IO/计算压力：资源加载，视口刷新  
      - 底层加载性能：  
      - 多线程+并行拆分  
  - 优化实例：UI，资源加载, scene，八叉树，批渲染，ECS，分块加载，复用滚动框架  
  - 优化结果：  
  - 思路：  
  - 工具：c_profile，  
  - 检测手段：  
- 内存占用：  
  - 内存泄露：  

- 属性同步

- GC

渲染相关：
- 场景绘制逻辑
  1. 两个摄像机：Obj， UI
  2. 渲染管线绘制顺序分类：GZ-， opaque， transparent， UI，2/3混合(被3D包围且SetIsNoDepthTest)， GZ+
     > 摄像机次序直接决定绘制批次(覆盖)
     > 同一摄像机内，先opaqut，再transparnet，再UI，再2/3混合
     > 就是吧绘制对象分了队列，不同队列次采用不同渲染设置，这个是可以人为组织og代码的时候操作obj集合来实现
     > opaque写深度测深度(都只用于静态背景类)，transparent只测深度不写，2/3d混合按**obj锚点的距离**排序绘制，只测不写
     > 总体渲染逻辑：背景内容之间，动态单元与背景之间有正常的穿插表现；同unit之间是按距离覆盖**不给穿模**(有2D)  
  3. 绘制实例：  
     - 战略地图(ObjCamera， UICamera，都是正交摄像机)：  
       1. Terrain(Tile/Water，气泡对话框，鼠标指示器等): Obj-Cam + UI批次
       2. Unit(Barr,Deco,unit,特效): Obj-Cam + NoDepthTest批次，空间位置进行区分
       3. 透明操作层：UI-Cam + UI批次(localZ控制)
       4. 表层UI：UI-Cam + UI批次(localZ)
       5. ![1740483252529](https://github.com/user-attachments/assets/ca774e3c-fc72-458f-9b78-85e49daaf78f)

     - 战场(ObjCamera：透视摄像机固定俯视角， UICamera：正交摄像机)：  
       1. 场景地表: Obj-Cam + transparent批次
       2. 地表网格绘制：Obj-Cam + UI批次
       3. 单元(阻挡装饰，陷阱特效，建筑单元，角色单元)：Obj-Cam + 2/3d混合批次(已经没有2D内容了只是为了提高批次)
       4. 透明操作层：UI-Cam + UI批次(localZ控制)
       5. 表层UI：UI-Cam + UI批次(localZ)
       6. ![image](https://github.com/user-attachments/assets/9aa9f394-6939-43da-b017-2ab450b5871d)

- 渲染应用
  1. cocos后处理接入  
    具体怎么操作(post pass)  
    - LUT：[LUT](../graph/readme.md#后处理)
    - 暗角：[暗角](../graph/readme.md#后处理)

  2. 阴影  
    - 1. 自定义阴影实现，游戏需求角色在xy平面移动，角色y绕着x轴有一定旋转(既不垂直于xy也不垂直与xz)，压地阴影需要固定投影面y高度且没有支持指定地表的轴向，动态阴影没有一个投影承载面(不是承载在地表且要正交阴影但是有bug)  
    - 2. 添加模型做压地阴影：模型空间根据光投影方向投射得到顶点偏移(光与法线夹角再根据顶点y推算投影向量长度然后顺光方向向量就得到与地表接触点)，压缩所有y分量，直接让压地阴影模型跟随原模型(半透异常，各种混合都不行，后面引擎加接口)  
    - 3. 离屏渲染：先绘制阴影，新创绘制场景，光源摄像机，将角色放置源点，获得缓冲对象的纹理，再进行shader变换(染色，三角缩放)后挂载到角色节点里面跟随角色(效果不太对且换算复杂..)，没有上述简单，放弃  
    - 4. shadowMap：  
      - [shadowMap思路](../graph/readme.md#阴影)
      - 实现思路：先根据viewPos位置和lightDir得到light的动态pos然后给出动态的frustum，绘制出深度图(具体怎么做❓❓) ，在每个角色下面挂在一个平面节点然后测试深度绘制(怎么分两个批次❓❓)

  3. 水体/地表网格  
     分层：不同地表类型(BGwater也算也算一种)  
     每层一个大节点，直接在节点上shader绘制，纹理重复或者纹理查找：
     
     1. bg或者land直接纹理重复，先uv确认是否符合命中tile，命中的uv放大(tileSize*siezPerTile)/textSize倍，实现纹理不缩放的重复采样
        > 为了增加样式，还加了装饰层，具体是按一些配置参数选中若干纹理资源进行排布，
          
     3. 边缘的先根据确认是否命中tile，命中了按tile记录索引进行合图上的目标纹理查找(off_tex_size)，然后将命中的uv换算到合图上目标纹理的uv：
        > a = uv-ceil(tile_uv), b = tile_tex_size/map_tex_size,  off_tex_size; (a/b * tile_text_size + off_tex_size) / batch_tex_size，这里大致就是换算到tex像素坐标进行换算
        
     4. 水体渲染——水面波浪效果 和 离岸深度加深效果：
        - 水体渲染：  
          通用方案：
          flowMap+normalMap, 菲涅尔镜面反射和边缘柔和，深度关系叠加，海浪
          
          实现方案——高度图uv偏移：  
          uv偏移图(flowMap)对uv进行两次不同倍率的uv偏移后叠加(fbm)，再加入时间变量产生uv移动，再进行法线图采样(❓❓❓)
          
        - 离岸深度：  
          通用方案：  
       
          实现方案：    
          根据tilemap计算sdf，然后平滑sdf，然后双线性插值得到暗度颜色叠加  
          (没有平滑出现折角锯齿，双线性插值后所成的平面如下图，会有折线)    
          ![image](https://github.com/user-attachments/assets/ece5cbe7-016f-44a1-8179-be68da19db3a)  

          
 
  5. 染色
 
  6. 描边
 
  4. 半透





- 图集

- dc

- 合批

- 渲染管线

- 压缩算法：pvrt
其他：
uml：
https://blog.csdn.net/qq_39847278/article/details/140821766

正则

SIMT并行加速

---
