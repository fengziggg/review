---
2024.11.18  
[对照面经](https://www.nowcoder.com/discuss/596064413442949120)

#### 项目架构:
公司lw引擎+公共代码+项目代码  

引擎提供游戏的基础共功能模型,特效,资源加载,场景,摄像机,光照声音,网络等基础功能  

公共进行了一些各项目共用常用的模块封装: 登录,网关,UI封装,屏蔽字,防成谜,实名认证,邮箱,充值等  

项目代码整体情况:  

1.状态同步
  - [状态同步/帧同步](同步模式.md)
  通过协议的方式与服务端拟定协议事务,进行状态同步

2.代码框架:MVC,ECS,ECGame
  - [MVC,MVP,MVVP](项目框架.md#mvcmvpmvvm)  
    大部分业务,包括UI模块都是用MVC的形式组织起来,不好的一点是出现了模块嵌套,但并非mvc本身问题,mvc本身可能存在没有必要存在view或者model的情况和ctrl臃肿
  - [ECS](项目框架.md#ecs)  
    战斗相关的业务用ECS进行改版尝试,服务端是用的ECS,为了与服务端同步好进行属性同步,同时方便的卸载加载组件,以及代码结构简单,但调试还不太方便
    
3.用到的设计模式：  
  - [单例](设计模式.md)  
  - [观察者](设计模式.md)  
  - [策略模式](设计模式.md)  
  - [指令模式](设计模式.md)

4.代码管理:
  svn,传统,co,update,reverse,merge,commit
  工具少量git(fetch,pull,push,merge,commit):  
  - 云效ci/cd蓝图  

5.开发流程:
  - 项目自行检出引擎工程进行编译(bat执行Cmake,ide编译工程,ide版本要求),编译过程中可以配置一些操作启用禁用,自定义拓展引擎功能(在引擎c层上开发,一般是效率考虑)  
  
  - 专门的公共代码检出和更新工具,检查版本和依赖进行公告脚本代码更新
  
  - 各种编辑器(没有集中):  
    数据编辑器(导表): 做了一些封装,用他的规则就可以对数据文件自定义解析,一般解析为py文件格式是字典等可以直接加载数据类型或者类化为对象再自定义一些工厂函数使用
    
    UI编辑器: 记录UI控件布局为配置文件,再解析为py的指令文件,继承UI对象的时候用指定文件路径名的方式执行布局指令集来初始化UI,将存粹UI布局隐藏独立开后又方便的在下方可以编写view相关的操作逻辑且还内聚为view 

    法术编辑器: 针对操作的都是引擎基础节点的公共方法,比如播动画,节点生命周期管理,空间操作,吧这些操作抽象为时间轴,时间轴的集合就是操作的集合,时间轴的时序就是法术播放的时序逻辑,附带condition, 发信号等控制指令就可以编排与外界的交互,对应的法术配置序列文件可以静态话下来以及需要的时候切换和维护,没有用状态机  

    地图编辑器: 2d瓦片地图,在对应的瓦片上放置单位就行,后续增加了一些预制组合之类;随机地图则只需要编辑关键点,联通关系,资源生成模板;  

    资源编辑器: 主要是编辑特效,gfx,mod, 例子发射器(基础元素面片,广告牌等的动画,生命周期,运动轨迹控制的组合),针对模型的材质纹理的周期性调整(UV动画)  
  
  - ci/cd平台: 内外网隔离  
    ci负责一些资源批处理工作,如代码文件化,资源检查(图片清理,模型大小,贴图缺失),资源自动加工(生成索引文件,导表到处)等,依旧处于内网  

    cd是将项目按固定格式组织后用提供的打包脚本吧资源,脚本打包加密为特定文件或者目录后部署在指定的域名下面,然后经过一系列校验手段(文件发布审核,md5+下载url的索引文件发布审核)进行发布到外网,游戏/游戏平台内置会去对比最新的索引文件,发现差异则根据索引内容引导下载更新,用于整包/补丁/工具文件的外网发布

#### 主要模块:  
- 通信  
  ecgame框架:  
  1.主要是封装了与服务端的通信功能,用dll的形式暴露接口给客户端使用
  2.服务器还支持了一个把部分逻辑集成到客户端的功能(打包为脚本文件),他们会通过ci吧他们一部分逻辑(不涉及安全的逻辑,如buff计算推演逻辑)集成到客户端,然后两边公用一份代码,两端都通过协议交互与之交互;共用逻辑,减轻服务端压力.
  通信的形势是拟定协议的方式,给要通信事务进行编号,拟定事务携带的参数类型,数量,用一份特定格式的协议文件进行记录,两端同步每次加新协议就要约定好后同步解析  
  解析出来的是对应事务的py函数,函数做的内容就是将参数压包和解包为协议规定格式的字节流,上层直接调用业务py函数,隐藏了这些字节流压解细节,然后给dll字节流后会用socket进行通信([socket](知识点misc.md)❓)自己实践过一次,但查乱码之类麻烦,后面用引擎封装的([大小端](知识点misc.md#大小端)❓)

- 业务
  - 特效  
    gfx，mod，叠加特效(❓),指令模式(❓)+组合模式  
    特效有一份完整的游戏资源目录：tex，model，mod/gfx嵌套？？
    gfx是粒子特效等的组合和对外封装
    mod是结合模型的进一步封装，可以指配到具体模型的具体动作的特效，组合了gfx和子mod
  
  - 模型：  
    1. 前期的模型规范，参考其他项目组和主观感受，原先2w顶点，面数(❓),定制依据(❓),后面定制为(❓)，一些分析工具的开发，模型性能上限测试，同屏200个不掉帧
    2. 角色对象的封装：
       ![image](https://github.com/user-attachments/assets/122a4600-1c15-4085-b89f-59e4ac7977a2)  

  - 战斗:
    六边形棋盘格回合战旗
    - 场景管理(区域事件)：

    - 框架和数据结构：  
      状态同步+指令模式（所有操作都是指令，用队列进行管理）+ECS：  
      1.在客户端视角，大部分指令都有客户发起和服务端广播表现两部分，少量不需要客户端发起行为(服务器逻辑驱动)：  
         等待输入指令，移动指令，普攻指令，魔法/技能指令，防御指令  
      2.客户端是行为收集就是简单的协议通知服务器，会有一些检查操作比如操作范围越界，目标选取逻辑等  
      3.客户端对服务端回复指令进行演绎，所有回复结果在服务器统一计算各端只是演绎结果可以保证一致性，也方便排查问题(结果不一致则确定是服务器问题还是单端客户端，客户端是某个客户端还是全都，还是网络问题)  
      
      UML：
      1.战斗实例上下文
      2.各种系统：
      3.各种组件：
      4.表现指令队列和指令对象
      
    - 表现指令队列：  
      指令队列的逻辑本身简单，顺序执行指令，指令里面获取上下文和操作目标(一般是角色或者空节点)，但有一些情况：  
      1.嵌套指令：  
        召唤魔法————这类魔法都有一个通用的施法动作表现指令，但在表现一半的时候需要开始召唤逻辑即入场指令，但指令是顺序串行(服务端是线性发送，表现时机是客户端动态计算的，对于服务端而言不知道什么表现上的嵌套逻辑，只知道是两个指令，客户端数据结构也是线性队列)  
        不改变指令结构，那只能通过更复杂的指令组合来描述这个业务，比如吧通用施法指令拆解为两块，前摇指令和后摇指令，然后通过前摇+Spawn(入场+后摇)的方式来实现，但这样服务端的指令组织变复杂需要关心到客户端的表现细节(为了表现拆分也在指令组织上进行拆分)，客户端需要对所有的通用施法表现(每个角色都有自己的施法表现)进行拆分，动画资源在施法这一个上*3且有工作量  
        所以对指令进行扩展支持子嵌套子指令，约定主次指令的顺序比如先发主指令再子指令，再约定指令搜索规则比如子指令自动搜索最近的一个目标类型指令进行嵌套，就可以在主指令执行生命周期内执行其他指令，具体时序可以靠信号机制触发比如动画k帧触发信号，特定信号进行子指令执行；思路类似于指令组  
      2.多段法术：  
      简单的可以直接服务端发送多个指令，首位相接即可，但指令的串行就会在每个指令表现完之后才进行下一个，而很多时候多段表现衔接是不等一个指令完全执行完就开始下一个表现，这种情况将多段衔接的逻辑下沉的魔法表现系统，里面也是个指令模式各个表现是单独的指令且可以组织为文件，组织为首段法术文件(攻击，关联，受击)和链接法术表现(关联，受击)，然后就是在一个法术指令内串联这些法术文件播放；法术指令的拆分不放到上层业务是因为上层指令需要与服务端同步，上移意味着服务端或者客户端业务需要关心到表现细节
      3.事务/指令合并：  
      4.防阻塞：  
      可能指令实现有bug，然后一直阻塞住整个队列执行(比如没正常释放)，需要一些超时保底自动推进机制  
      5.乱序：  
      比如前期客户端有自己插wait()的操作，如果逻辑异常在处理一个正常的wait0()里面先插入了一个客户端wait1()，然后会收到服务器对第一个wait0()的表现act0()但被wait1()卡住没表现,且第一个wait0()没有结束回合还能继续操作又收到第二个wait2(),队列为[wait1,act0,wait2],这个时候再操作使用了wait1()和执行了后续的act0()，但服务端会以为这是wait2()执行又给后续act1()，队列[wait2,act2],实际表现就是点第一下客户端没反应，第二下的时候执行了第一下的表现，点第三下的时候执行第一段到第二段的表现，这跟用户操作的预期是不一样的，而且服务端也会错误的收到第三个wait的输入；处理办法可以是给cmd都加编号这样指令执行的时候就可以进行一些异常检查；项目的处理是禁止这种乱序的源头比如不允许客户端插入wait，还有加一些指令队列实时打印进行调试  
      6.进阶预测机制：  
      
    - ECS：
      
    - 魔法：
      
    - 加速：
      
    - 六边形地图：
      
    - 录像：
      
    - 观战：
      
    - 联机：
 
  - UI系统/管理/优化/携程应用
    - 分辨率适配UI
    - 2^n尺寸
 
  - 场景管理
    - 状态机
    - 流程
 
  - 地图
    - 地图生成
   
    - 渲染TileMap
   
    - 寻路
   
    - 性能
   
  - C交互
 
  - 工具
     - 自动打包提交

- 资源

- 打包相关

- 热更

- 代码管理

- 上线相关

- 性能优化

- GC

渲染知识应用：

- 渲染相关应用
  - 阴影,染色,半透,LUT

- 图集

- dc

- 合批

- 渲染管线

- 对象池

      
---
