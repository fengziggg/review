1. 封装，继承，多态：
   - 封装：将数据和行为进行隔离，控制用户访问权限和限制行为，为复用提供基础
   - 继承：代码重用，子类继承所有数据和成员(除了构造析构友元静态和final)，可以访问公有，子类不能访问私有，和外不能访问私有友元
   - 多态：父类指针指向或者绑定子类，使得可以执行子类的行为，又保证父类的逻辑正常，父类指针就像占位符代表了这个继承树的所有实例，在编码的时候可以用一个同一个类型执行所有未知的子类行为

2. 多态实现方式：
   - 静态多态：重载(包括运算符重载)(同一个类之间)，重写(子类覆盖父类)，编译时就知道调用函数
   - 动态多态：❓虚函数，虚函数表，实现谁调用，谁实现
   - 增加代码复用能力和增加拓展性
   - 类内或类间同名不同签名：重载，类间同名同签名：重写，类间虚函数同名同签：虚函数多态

3. final：❓类后面阻止继承，虚函数后面子类无法重载

4. 虚函数标：⚠️

5. 智能指针：❓为了保证动态内存的安全，对原始指针进行的类模板封装

6. 匿名函数：定义的过程动态创建的栈对象，重载()，会自动释放

7. 右值引用，为社么要引入右值：
   - 配合移动操作❓，静态语言比如在参数传递中都是构造一个替身对象传递值，移动类似于不要代价高的构造直接迁移原对象，类似于闭包？
   - 移动一般用于快消亡对象或者表达式等右值，比如函数内的返回值，出了函数就销毁，可以用右值引用来接住

   - ❓完美转发，可以在函数内部转发给其他函数??
   - 拓展可变参数模板？？
  
8. 左值引用和指针：
   - 左值引用是别名(编译时候命名表的一个名字常量，指向对象本身，所以不允许更改也必须初始化好？？❓)
   - 指针是个存储地址的变量，所以也有自己的内存空间

10. weakptr：
    - ❓是否真的没有计数: 控制快弱中有计数，make_share构造的控制块跟指针在一起，new的控制块跟指针不同位置

11. malloc❓：
    - malloc是C的库函数，下面对应俩中策略调用系统调用，brk和mmap
    - 小于128k用brk，分配出的内存放于堆顶，free不还给系统而是内存池中缓存
    - mmap是直接向系统申请文件映射区的内存，free也是真还给，所以要频繁切换内核态会有消耗
    - mmap容易内存泄漏，同时使用麻烦申请要检查成功否，归还要清空指针值为null
  
    - mmap❓：
    - 频繁切换核态，耗时
    - 真归还，所以每次申请都要先缺页中断

    - brk❓：
    - 都是小内存，频繁会导致内存碎片

12. 释放指针的容量确定：
    - 指针申请的时候会多分配16字节存储分配容量
    - 释放的时候左移p的值得到容量

13. define/ const:
    - define是文本替换，在编译之前，所以无法参与编译后的类型检查，也无法调试
    - const是常量空间，在编译之后，能参与类型检查和调试
    - define占多分内存，存在代码段中，const占用一份内存静态space
    
14. 编译过程：
    - 预处理：头文件编译，宏定义替换，输出.i
    - 编译：词法分析，语法分析，类型检查，输出汇编文件.s
    - 汇编：翻译机器码，输出.o
    - 连接：将机器码和引用库dll等连接起来，生成exe

15. 锁的原理：
    - 计算实现层面：计算的时候取内存数据都先存储一份内存数据快照，计算完之后要刷新回去之前先对比快照情况是否更改
    - 更改了则放弃这次计算修改的结果

16. 原子操作：
    - 硬件层面的，汇编指令有一条指令可以锁住总线，一旦锁住其他线程无法通过总线访问内存

17. class和struct❓:
    - 默认权限不同，class默认私有struct默认私有
    - class可以用模板参数，struct不行
    - c++是为了兼容struct不要用class替换的时候还要去做兼容性修改

18. 内存对齐：
    - 寻址的时候是按定址还是变址，定址可以定长，变址可能需要特定编码比如哈夫曼无重复编码
    - 对齐寻址快，移植性好❓

19. 进程间通信：
    - 文件描述符是什么❓
    - pipline，内核的缓存，返回两个文件文件描述符r/w，只能半双工，不适合频繁进程交换
    - queu，全双工，但需要频繁切换内核态
    - 共线内存，全双工，不切换，但需要加锁
      
20. 线程通信：❓
    
21-23. socket，多路复用，epoll的LT和ET(❓不懂用途，知道大意)
    - 都是监听文件描述符，文件就绪就通知系统进行相应读写
    - select，精度高移植性好，但限制fd数量且需要切换两次核态拷贝fd
    - poll，不限制fd优化了调用参数(不用重制fd_set)，精度低且也是每次调用都需要拷贝fd进行核态切换
    - epoll：进一步优化参数调用，只需要在epoll_ctrl拷贝一次，epoll_wait不再需要优化了数据拷贝效率，但只有linux
    - LT：对于读操作有数据就会一直通知有读就绪，在写的时候就一直通知写就绪
    - ET：只有在状态切换时会通知

24. 类的生命周期：⚠️
    - 七个阶段，加载，验证，准备，解析，初始化，使用，卸载
    - 验证，准备，分析阶段为类的链接阶段
    - 全局在mian之前被创建，main推出销毁
    - 静态在第一次进入作用域被创建，main退出销毁  （？？函数不是编译就创建好了？？）
    - 成员变量在进入作用域被创建，推出作用域销毁
    - new的在知道free之前都存在⚠️❓

25. 父类构造/析构，虚函数⚠️
    - 构造不能虚函数，调用虚函数需要虚函数指针，虚函数指针是实例对象的属性在实例内存，实例对象需要先创建好对象需要构造函数，矛盾
    - ⚠️❓析构函数可以虚函数，且一般虚函数，这样多态的时候就不会因为不小心绑定了父类指针导致只执行了父类的析构(❓析构不能继承所以只有父类的析构必须靠多态来自动切换指向？)

26. 死锁：
    - 条件：独占资源，自己不放弃，别人无法剥夺，循环引用
    - 接触死锁：打破条件之一，比如watchdog后自己放弃，或者只能固定次序加锁
      
27. 面向过程/对象：⚠️
    - 有无状态
    - 对外暴露的都是一个个步骤/方法，即时将方法封装为一个更大的方法，也只能是提供一个个方法，需要哪个调用哪个，**复用的时候每次都要(重新)执行一些方法**，再自己处理
    - 将业务逻辑完整包装，对外除了暴露方法，还可以保存状态，使用的时候不需要关心提供的服务的准备数据或者状态，**复用的时候也不需要再次执行一次前面步骤**

28. i++和++i左右值
    - i++右值，返回一个副本后i是被修改了
    - ++i左值，先修改了i然后返回i内存本身
    - ++i效率高，不需要拷贝右值
   
29. vector/List：⚠️
    - vector是动态扩容的连续内存控件(顺序表)，头指针尾指针和剩余空间指针
    - 适合尾插不适合头插，随机查找，需要动态扩容
    - list是双链表，不需要扩容，插入都o(1)，查找o(n)不支持随机查找

30. 变量的初始化和内存分配时机：⚠️
    - 全局，静态，常量都是在编译的时候初始化和分配内存
    - 其他变量在编译初始化，运行的时候分配内存

31. 多进程：
    - linux: fork
    - windows: createprocess
   
32. 空对象指针能调用函数：❓
    类对象的所有成员函数都是定义在类外边的(也包括静态函数)，如果调用没有涉及任何this操作则可以调用

33. sharePtr线程安全：引用技术的维护是内部线程安全的，但是用指针指向的对象来做什么事情这个业务是没管的

34. pushback传入左值/右值：⚠️
    - 传入左值用拷贝构造，传入右值移动构造
      
35. ⚠️move实现：将一个左值引用强转为右值引用，避免了拷贝构造，只是改变所有权，没有拷贝或者(搬迁??)里面的内存

36. 完美转发：❓⚠️
    - 针对模板函数对内部函数调用的参数传递情形，给模板函数是左值，给内部参数就是左值，反之同理

37. 空类中有什么东西：
    - 默认构造函数，默认拷贝构造，默认析构，默认赋值运算符，取值运算符，常量取值运算符

38. explict/implict:❓⚠️
    - explict用于调用签名只有一个参数的构造函数(一个参数+n个默认也算)，防止类构造函数的隐式自动转化(???)
    - implict，默认拷贝构造是implict

39. 成员变量的初始化顺序：❓⚠️
    - 初始化顺序表初始化的时候这里的顺序是无关的，这个时候取决于定义顺序
    - 构造函数里面初始化则为函数里面定义的初始化行为的顺序
    - 常量成员必须在初始化表列里面初始化,常量是需要定义时候初始化的，（所以在这个特殊的初始化地方？？）

40. 指针的大小：与机器计算机字有关系，计算机字决定了一次寻址能寻到的最大位置

41. 野指针和内存泄漏：❓⚠️
    - 野指针：指向了一个已经释放的内存地址，一般要用合理的指针初始化，用完要null(用的不对)
    - 内存泄漏：堆内存失去了指引，常驻内存，用只能指针管理，尽量避免自己new，数组用delete[]

42. malloc和new：⚠️
    - malloc/free是标准库函数，new/delete是运算符
    - malloc从堆上分配内存，new从自由存储区(还可以重载为stack或者静态)
    - malloc很原生，失败返回空，成功返回void*，没有钩子行为construct/discontruct
    - new失败抛异常，成功返回对应类型指针，中途关联钩子行为
    - new的流程：调用op new()函数，分配一块足够大，原始的，未命名的内存，调用构造函数构建对象，传入初值，返回指针
    - deleter流程：调用析构函数(不是delete)，在调用op delete()释放内存

43. 多线程：可能资源竞争，死锁

44. STL：组件库，数据结构+算法架构，六大组件：allocator, container, adapter, iter, functor, algo⚠️

45. 指针和迭代器的区别：⚠️
    - 迭代器是对指针封装的模板类，模拟了指针的常用操作
    - 迭代器指向的是容器，返回的是引用
    - 指针指向所有

46. 线程的状态：
    - 就绪等大，阻塞，运行，创建，死亡
    - 锁：互斥锁，自旋锁，递归锁，读写锁，条件锁❓

47. map和unorder_map:
    - map是红黑树，操作效率高logn，空间占用大时间换空间
    - underorder_map，hash表，操作效率极高，构建费时
      
48. vector的push_back和emplace_back:❓⚠️
    - push_back会经历一次构造(有参)，然后在经历一次拷贝/移动放入容器，有点安全
    - emplace_back直接在容器尾部构造，比push_back少一次构造，优点快大部分可以平替push_back
    - emplace_back但只能用于往容器构造新元素(？？？)，push_back则可以填充已有元素

49. vector的resize和reserve❓⚠️
    - resize是改变vector的size，会增加或减少元素
    - reserve是改变capacity，不会改变元素数量只是优化内存分布

50. vector扩容优化：❓⚠️
    - 内存不够时会用1.5/2倍进行扩容 ？？？
    - 可以自定义capicity ？？？

51. vector如何判断应该扩容：❓⚠️
    - 比较size和capacity
   
52. unorder_map如何扩容：
    - 当factor达到0.75就会重新分配桶，一般为2倍也可自定义max_load_factor
    - 将已有内容重新hash进新桶

54. 空类的大小：1Byte

55. weak_ptr的实现：❓⚠️
    - 引用计数器：统计引用，寄存器：存储ptr

56. f（int a, int b）中ab的地址是相邻的

57. 拷贝构造和移动构造：⚠️
    - 拷贝构造是创建一个新对象复制传入值
    - 移动构造本质是指针的拷贝(命名标关联的指针??)，堆上内存所有权的移交，一般用于临时对象或者右值对象

58. lambda捕获： ⚠️
    - 值捕获和引用捕获
    - 引用捕获如果导致闭包，闭包里面是临时变量，参数等，lambda的生命周期比捕获长会导致引用悬空

59. hash碰撞的处理：⚠️
    - 开放定址，拉链法，再哈希，公共溢出区
    - 建立：❓
   
60. 线程安全控制：
    - 加锁，互斥量，原子操作，条件变量❓

61. 









