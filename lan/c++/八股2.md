### 基础篇：
1. 面向对象和面向过程和优缺点：
  -
  
2. c和c++的区别：
  -
  
3. static的作用：
  -
  
4. const的作用：
  -
  
5. synchronized和voliate的区别
  -
  
6. struct和union的区别
  -
  
7. struct和class的区别
  -
  
8. 数组和指针的区别：
  -
  
9. 程序的执行过程：
  -
  
10. 指针和引用的区别：
  -
  
11. malloc/new free/delete的原理：
  -
  
12. ++i与i++
  -
  
13. 函数指针和指针函数
  -
  
14. 指针数组和数组指针
  -
  
15. 常量指针和指针常量
  -
  
16. 值传递，指针传递，引用传递的区别
  -
  
17. extern “C”
  -
  
18. 大小端
  -
  
19. 深浅拷贝，写时拷贝
  -
  
20. 函数重载，重写，隐藏
  -
  
21. 内联函数和普通函数
  -
  
22. const和各级指针/引用的情况
  -
  
23. 数组和链表--
  -
  
24. 野指针和悬空指针
  -
  
25. 全局作用域，局部作用域，静态全局/局部作用域
  -
  
26. 内联函数和宏定义的区别
  -
  
27. const和define
  -
  
28. 左右值引用
  -
  
29. 几种构造函数
  -
  
30. 如何避免野指针
  -
  
---
### 面向对象：
31. 函数模板
  -
  
32. 泛型算法
  -
  
33. 拷贝赋值和移动赋值
  -
  
34. 虚函数，静态绑定，动态绑定
  -
  
35. 虚析构函数
  -
  
36. 多态
  -
  
37. 广义继承的三种形式
  -
  
38. 抽象类和普通基类
  -
  
39. 抽象类和虚基类
  -
  
40. 多继承：
  -
  
41. 函数对象：
  -
  
42. 菱形继承
  -
  
43. 对象的构造函数
  -
  
44. 不同生命周期对象执行析构的时机
  -
  
45. 派生类的构造和析构过程
  -
  
46. 类的封装：--
  -
  
47. 默认参数函数：
  -
  
48. 智能指针：
  -
  
49. 纯虚函数与虚函数
  -
  
50. 哈希函数
  -
  
51. c++强制转换：
  -
  
52. 构造为什么不能是虚函数
  -
  
53. 虚函数可以是内联函数吗
  -
  
54. strcat/strcpy/strcmp
  -
  
55. 虚函数和静态函数的区别
  -
  
56. private/public/protect
  -
  
---
### STL
57. 六大组件
  -
  
58. #### vector
  -
  
59. vector底层原理
  -
  
60. 扩容倍率的原因
  -
  
61. 扩容的过程
  -
  
62. 扩容因子1.5和2
  -
  
63. size、capacity、resize、reserve
  -
  
64. 为什么会迭代器失效
  -
  
65. 迭代器失效的原因：
  -
  
66. push_back和implace_back
  -
  
67. #### list
  -
  
68. list底层原理
  -
  
69. 常用接口
  -
  
70. vector、list插入问题
  -
  
71. vector、list各自优缺点
  -
  
72. vector和list末尾删除、中间删除，迭代器会如何
  -
  
73. vector/list特性
  -
  
74. 总结vector/list实现原理，常见操作时间复杂度
  -
  
75. #### deque：
  -
  
76. deque实现原理
  -
  
77. deque中控器
  -
  
78. deque的迭代
  -
  
79. deque的数据结构
  -
  
80. deque的常用接口
  -
  
81. vector/list/deque的选择原理
  -
  
82. list怎么删除元素
  -
  
83. 优先队列：
  -
  
84. STL动态连接可能产生的问题
  -
  
85. #### map和unorder_map
  -
  
86. map和unorder_map的底层
  -
  
87. map和unorder_map的优缺点
  -
  
88. set底层为什么是红黑树
  -
  
89. 为什么关联容器的插入删除效率比序列容器高且不会iter失效
  -
  
90. 为什么map/set没有reserve
  -
  
91. map和set的区别，如何实现：
  -
  
92. vector/map越界访问会发生什么，vector删除元素会不会释放空间
  -
  
93. map[]和find的区别
  -
  
94. #### stl内存优化：
  -
  
95. 频繁对vector.push_back的影响
  -
  
96. hash_map和map的区别，用途
  -
  
97. set的用法和特点
  -
  
---
### 内存
98. #### 内存泄漏是什么，如何解决
  -
  
99. 常见内存泄漏：
  -
  
100. 如何避免内存泄漏
  -
  
101. 常见内存错误，和对应策略
  -
  
102. 内存的分配方式：
  -
  
103. 堆和栈的区别
  -
  
104. 控制c++内存分配
  -
  
105. #### 内存对齐的使用场景
  -
  
106. 内存对齐对应几类数据类型以及原则是什么
  -
  
107. 什么是内存对齐
  -
  
108. 为什么要内存对齐
  -
  
109. 内存对齐的例子：
  -
  
110. #### 内存分配可能出现的问题
  -
  
111. 指针是如何传递内存的
  -
  
112. 什么是野指针，如何预防
  -
  
113. 内存耗尽怎么办
  -
  
114. #### 什么是内存碎片，如何避免
  -
  
115. C++五大存储器
  -
  
116. 内存池的作用和实现方法
  -
  
117. 如何构造类，限定在堆或者栈上分配内存
  -
  
118. 物理内存和虚拟内存：
  -
  
119. 变量的存储位置和程序的内存分配
  -
  
120. 静态内存分配和动态内存分配
  - 编译的时候分配的内存或者分配完一直存在且不变大小，直到程序结束：静态变量，全局变量
  - new/malloc, free/delete
  
121. 段错误是什么，什么时候出现
  - 内存越界访问：
  - 野指(未初始化、已经释放)/空针访问，数组越界访问，只读区访问
  - 堆栈溢出
  
122. 内存快大小导致malloc返回空指针怎么处理
  -

123. 可执行文件的一般结构：
   - 文件格式,指定平台,入口地址
   - 数据段(静态变量，全局变量)，代码段(可执行代码和只读数据，二进制机器指令)，堆，栈
