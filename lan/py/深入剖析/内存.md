#### 内存模型：
py在底层c的内存分配机制上，还实现了自己的内存管理机制  
内存池在小于512B的时候会接管，大于用malloc，c+的malloc也是分层的，小于128Kbit时候用brk，大于用mmap划分内存
- 结构：块-页-池-类型表

- 希望尽量少的内存碎片，所以不能任意变长分配，尽量按固定规格定长分配，就是块的思路按size连续分配
- 但是同一size的数量未知不能放任不管，所以引入了定长的页，页的尺寸固定4KB，页也是连续分布，页内块size不同决定一页的块数量不同，size按8字节起步8字节一般最大512字节所以有64种规格
- 连续挨着的页可能是不同块size类型的，所以靠索引吧同类型的页串联起来，双向链表头就是池
- 每种类型的池的表头都用一个表指向可以按size快速找到pool再由pool的相关索引找到课分配页和块

页内结构：
- 页的头部有poolheader，两个指针用于页间串联，一个freeblock指向当前生产队列的队头，nextOff标识产出队列不满足时new产品的开始位置，count标记标识用于标识页的状态是否以满以全空
- 维护其实就是一个动态构建的链表(指向可用block，巧妙利用了回收block的空间占用来写索引也没事，猜测union实现)+生产者消费者模型
- 生产者消费者模型，product有两个来源，一个是当已有product不足再请求信号量为负的时候触发new，在offset处new分配
- 一个是已经分配出去的块回收回来，product**头插法**插入freeblock链表的**头部**，意味着一开始的freeblock会放在后面，新插入的freeblock会代替成为第一个指向，同时用这个**空闲空间写索引**指向之前的freeblock
- consume没有特殊情况，只是一直限制从freeblock指向的**队头**开始消费

页间结构：
根据页的状态动态决定从页链表上移除还是加入，只有可使用的才加入，全满的移除缓存，全空闲的也移除回收

实现了尽量按size连续分配，又能支持不同size混合，同size动态扩容

---
#### 垃圾回收机制：
引用计数-标记清理-分代回收
引用计数：
- 缺陷：无法识别循环引用
标记清理(引用计数的补丁)：
- 无法识别循环引用带来两个问题：无法知道什么是该清理的(认不出，可能有好的循环引用比如用户写错了但还是用着的循环引用)，进而无法知道什么时候该清理(没有触发时机认为都活着)
- 标记清理可以找到循环引用，也可以判别是否是清理时机(这两个问题统一为是否被根节点引用者)
- 缺陷：需要遍历，高频+大规模触发性能问题
分代回收(标记清理的补丁)：
- 可收集对象都被双链表串起来
- 分规模串成三个不同的队列，标记清理在队列规模内执行
- 时机按队列设定的时序阈值，队列间进位控制时序来触发：时序是obj的创建次序idx，idx不断递增，对三个代的时序阈值thread分别取模，取模结果对应这代是否要gc，对取模结果或运算
  > 即idx不断递增，每个idx都会触发若干个代的gc是确定的
  > 第一个代的自变量是idx，后两个代其实不是idx，而是第一代的进位次数
  
demo中的标记清理逻辑：
正常是两边遍历，一遍找根(节点的出度节点的引用次数：obj -> obj1(-- <-))每个节点只处理当前出度，一遍按根为规模遍历标记，然后差集  
demo找根的时候在全集规模遍历每个对象的时候，又同时开始对该对象引用图的遍历，后续列表中可能有些已经被处理过了...  
第二遍坐标记的时候也是直接遍历全集而不是根，然后全集里面**还**没有被根给探索到的都视为待定不可达，后续列表遇到根同样遍历该根图谱，会修正之前那些暂时不可达的...  
写的很难看
