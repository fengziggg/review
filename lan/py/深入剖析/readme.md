##### 1. C structure  
1. 结构体define(摸版):    
  - 类对象结构体定义: PyObject, PyVarObject, PyTypeObject  
  - 实例对象结构体定义: PyFloatObject, PyIntObject  

2. 类对象实例(被高级语言的关键词干扰，其实都是内存对象来着):  
PyTypeObject实例化出:  
  - 上层基础类型对象: PyObject_Type(name: object), PyType_Type(name: type)  
  - 内置基础类型对象: PyFloat_Type(name: float), PyInt_Type(name:int)...  
  - 自定义类型: class XXX(object), 类的定义是硬编码的，估计运行时执行时也是将硬编码的类走与内建类型类似的流程  
    
3. 实例对象：  
  - 调用类对象比如float的构造函数float()，然后执行一段内存分配逻辑创建的 由PyFloatObject定义的实例比如3.1415926  

4. 引用关系:
  - 每一个实例对象都要引用一个类型对象：一个float实例对象3.14159的c结构体中type指针指向类对象 PyFloat_Type(name: float)
  - 类对象也是个实例对象，同样指向类型对象即更上层的PyType_Type(name: type)，同时type的类型也是指向type本身
  - 类型指向是用于存放操作方法的，即实例调用的方法都要去对应的类型实例里面找，类型实例都是单例比如float等(每种类型的定义对象只需要一个)(自定义类对象实例应该也是如此)

  - 继承关系存在类型对象里面的ob_base引用里面,即每个实例上是没单独村一份继承关系的(没必要)
  - 整体的追溯逻辑是先从实例type找到类型对象引用，然后类型对象的继承关系里面索引继承链
  -  内置的类型对象实例的继承关系都是指向 PyObject_Type(name: object)即都是继承object，自定义类的顶层基类也是，然后派生类再在派生类实例对象中保存继承关系的引用指向父类型对象实例
  -  object的父类没有继续指向自己，说是怕递归

5. 可变/不可变，定长/变长：  
  - 可变对象是只对象的内存数据会不会改变，不会改变的一般只会被引用和改指向的引用(=)，而会改变的可以做容器会被持有后修改内存上数据(一般是函数接口)，当然也可以改引用另一个对象(容器的操作符重载很多都是返回引用而不是原地操作，+， *)  
  - 定长/变长对象是指统一类型的对象不同实例size会不会变  
  - 不可变对象可能变长(int)也可能定长(float)  
  - 可变对象可能用变长头定义也可能用变长头，但实际都是变长的，同一个对象的size都会变，更别说不同对象
  - 实际变长的类型(bytes, str, list, dict)的size除了头部还要吧变长的内容也算进去(bytes:sval, str: ，list: ob_item, dict: dict_keys)

----
##### List：  
0. 可变对象，变长结构  
1. 内存结构体: PyVarObj + allocated + *ob_item + GC收集头 (头部固定3+2+3)  
2. 常用操作：增append,insert, concat, +, *, 删remove, pop，改=, 查[], index  
3. ob_item指针数组动态扩容：  
  > list_reisize: 增长模型 new_size + new_size//8 + (new_size<9)3:6，PyMem_alloc  
  > ![image](https://github.com/user-attachments/assets/6153d434-9f9c-4c09-a263-21caeb96f13c)  ❓❓（0, 4, 8, 16...怎么来），  
  > list_ass_slice: 对内存上区间数据进行修改，删除即前插(O(n))，或者直接该值，会释放对象

4. append: 检查，resize，引用，setItem
5. insert: 检查，resize，引用，前插迁移新内存上数据
6. pop: 检查，调用resize或者ass_slice，resize占用list的引用/ass_slice要预先增加一次引用
7. remove: 遍历比对后ass_slice

----
##### Dict:   
0. 可变对象，定长结构特殊处理  
1. 内存结构：GC头 + 定长头(特殊定制的定长结构) + size + ma_key(这个指针本身) + ma_val + version + ma_key的展开内容[size + fraction + used + ref + lookup + 预分配[索引表(1字节*8个==1个字) + 5个实际entry(5 * 3)]]<br>
== 3 + 6 + (5 + (1 + 15)) = 30 存储字(64位为240Byte)  
2. 预分配内存：  
  > - 触发内存分配时机: 按 **2^n** 规则扩容逻辑容量(索引覆盖空间),实际空间分配为逻辑空间的 **2/3** ，然后里面实际使用到这个界限就会触发重新分配内存的计算，这里有三个容量概念(逻辑，实际分配，实际使用)  
  > - 重新计算容量：会搜集现有的所有元素(有些已经失效逻辑删除)，根据实际元素决定新空间大小，大于上一次的实配size(逻辑size*2/3)就会扩容，小于上一次逻辑size/3就会缩容，且逻辑size都以2 ** n为卡点  
  > - 空字典预分配8个逻辑槽位，然后实际size为5  

3. 数据结构：hash表:  
  > - 这是实现map，所以是没有map的不要习惯性带入map思维，用数组实现map  
  > - 用hash实现map：给key能找到地址来取值，一般到这里就看可以实现映射了map了，但后面还有hash冲突问题，带hash冲突处理的hash表其实就是拓展加了线性搜索逻辑的hash(**已经不是原生hash**了，既有随机访问也有顺序比对)  
  > - 以线性探测为例：每一个key对应的是一连串hash值(甚至是所有hash空间，只是加了时序变量)，这些冲突可能是自己的key已经被占用的冲突，也可能是自己在线性探测的时候打算占用其他hash空间的位已经被用了(每一个key都对应一串hash槽位，那其实槽位之间都是相互冲突的就是插入时序问题)，还可能是被其他人线性探测的时候占用导致自己放不下，所以搜索和更新(也要先搜索才知道能不能用)可以看作本质还是个顺序访问机制的过程(**直接映射就是这个过程的不冲突特例**)  
  > - 链表法应该没有冲突风险高的问题但内存负担增大  

4. 数据结构: 二级索引:  
  > - 本来一级索引就可以完成map映射逻辑了(顶层结构体里面的ma_value是split模式下启用的可能就是这个用法，历史遗留), 二级索引是的entry可以按插入顺序遍历(不推荐用这个特性),文章说是为了吧预分配空间这个设计中没用到的空间节省下来，但如果用一级索引表，然后也只分配fraction个元素，当插入的时候计算到达边界就扩容不是也可以支持扩容且不会预先分配满所有逻辑size❓❓毕竟检查是否扩容只需要逻辑并不需要一定依赖索引表这个数据的状态❓❓  
  > - 删除的时候不会真的删除，只会给索引表对应槽位设置dummy状态，表示槽位到实际分配conn中断，后续继续插入key冲突的元素(一个key对应若干槽位)可能可以放入dummy更新dummy(评论区,待考证❓)，查找的时候则会直接跳过dummy且不会中断  
  > - 重新分配内存的时候则会新建索引表，比如根据实际元素重建索引，无用的dummy会被下面的冲突key取缔  

----- 
##### 作用域与命名空间  
作用域语法静态划分依据：
对象: 属性空间(__dict__), 堆空间  
模块：模块对象，全局命名空间，也是属性空间，堆空间  
函数：局部命名空间，栈空间  
嵌套情况：  
函数嵌套函数，函数嵌套类，跨作用域或者说在子作用域内传递，有专门的命名空间闭包，不清楚是栈还是堆❓  
类嵌套函数: 必须通过self访问，其实类的属性空间并没有给函数留空间而是直接按类名划分了空间然后绑定到类上其实是一类特殊的全局函数，通过首参self表征实例空间的访问❓  
类嵌套类：没有self定义入口，可能是语法没有覆盖到的部分了，不做讨论  
所有的函数和类都相当于对全局命名空间的嵌套，但不会用到闭包空间，这个全局命名空间可以看作嵌套的特殊表达  
名字可见规则：...

命名空间的访问顺序：  
与作用域名字辐射范围相反，辐射层级嵌套越少，越优先访问，LEGB

----
##### 函数对象：  
对象职责划分:  
> 对象的主要职责是储存数据(几乎都是引用)，然后各类型的对象只不过是职责不同储存不同类型数据
> 函数对象主要存储codeObj并且主要功能是执行里面的指令
> 模块对象的主要职责是提供动态访问修改的存储空间，但比较模糊的是模块对象也带有函数行为，第一次import的时候也可以视为是执行模块全局指令

虚拟机运行时个角色划分:  
> codeObj: 编译阶已经划分好各个codeObj，codeObj之间的引用关系由co_consts维护，直接用链表方式引用住  
> > 提供字节码，co_names命名表(没有存储用到的对象本身，只存了命名然后去全局空间找)，co_consts常量表(或者叫单例表，里面包含codeObj，也包含类似int等常量，即codeObj创建出来后都是单例且引用关系也固定了)  

> module: 程序肯定有一个main模块作为入口，这个时候main模块的定位既是函数会执行里面的全局指令，也是存储空间提供dict作为该模块下的global  
> > 指令无非常见运算(方法调用)和def(也是一种运算)和import(也是一种运算),def会在堆空间创建function对象(会存储子codeObj引用)供后面其他运算使用(call时候的LOADNAME)，第一次import也会执行该模块里面的指令，该运算运算该定义定义，不知道有没有开辟帧❓  
> > 模块的属性空间会作为该模块下所有子codeObj运行时依赖的一切全局数据的来源，即一个模块下的子CodeObj的非栈非静态空间都是派生自这个模块的属性空间，而模块间是没有这种子承关系的，即使是main也不是其他所有模块的父global空间，即命名空间在模块就到顶了  
> > 模块的定位比较暧昧，既像特殊函数(第一次import时或者reimport)会执行指令，又像命名空间的基本单位模块提供global

> frameObj: callfunc的时候开辟新上下文(状态机)，主要存了上述两者的引用关联起两者    
> > iLast指引该状态机下对应的codeObj执行到哪  
> > 提供各种空间的引用global，local，varplus什么的，codeObj执行的时候查co_names找对应的对象就在framObj指明的这些空间里面找  
> > 递归的时候是同一个codeObj，每个帧对象都指向同一个codeObj但是iLast不一样，然后一个codeObj执行结束返回值存储在上一个帧对象的临时变量栈的某个位置上，然后继续该栈的运算

> function: 主要提供对codeObj的引用，自己也记录了对global等的引用，但是local没有，忘了细看原因  
![d870fba9c1f6a8283f64d7b475679d0](https://github.com/user-attachments/assets/0bf56bd1-2713-4e52-931c-2204c55c9c55)  
真正的指令执行者都是codeObj

----
##### 类  
mro: py3深度优先，C3算法❓  
子类优先于父类，继承表列顺序在mro里一致  

元类：类型对象的构建工厂，其构造函数返回值为类型对象(自定义或者内建类型对象)  
重载元类对象和构造函数，介入**类型对象实例化**过程，类型对象实例化关乎实例对象的属性定义，如属性定义，检查
重载new介入**实例对象实例化**过程(类型对象的静态函数)

----
##### generator  
作用：节省内存，异步  
def：yield标志编译时区分，生成genObj，附带悬空frameObj  
send/next：载入data到frameobj栈顶，frameObj入链，执行frameobj  
yield：断链，跳出frameobj指令流，返回值  

async：有await的或者转化genObj用途  
await：yield from 或者 while/yield/send，最底层还是yield(await Obj)，是最底层awaitObj的上层中介，**一个是下达执行到yield，一个是穿透回顶层**，单纯yield while不一定有穿透会顶层的作用看自己实现  
> ret = await xxx❓, ret = awaitObj.send() ❓

基于多路复用IO(epoll)的事件系统：用于调度协程；协程解决job对线程/进程的阻塞问题本质还是靠逻辑分块，这个时候协程是语法糖层次的东西  
事件循环系统demo:   

----
##### 内存  
页：内存组织基本单位，一般4k  
池：不同规格的内存页，块的大小为long的整数倍到512Byte，同规格池会双链表串起  
池表/页表：不同池的表头列表  
页内的组织是顺序表和块链表的动态结合，一直顺序申请就是顺序表只准备容量，所有的离散缺失块就用链表串接，在size里面没有被链表记录的就是按块规格分配的连续块  

引用计数+分代回收+标记清理  
基础结构：  
> GC_Head：每个Obj初始化的时候都会偷偷执行的一段逻辑给Obj头部注入的数据体，是gc_generation链表结构的节点，4个存储字
> gc_generation：gc_head的双链表和以写阈值字段


1. GC：回收没有被外部引用的异常残留内存，或不可自动回收内存，GC不等于回收循环引用，而是正确的时机(没有外部引用了)回收循环引用  
> 有外部引用的都不回收，即使是循环引用  
> 没有外部引用但有循环引用的要回收

2. 引用计数有缺陷，循环引用，但在特定时机才会有问题，正常情况释放是会被正常回收的  
对于异常情况，分代回收提供回收时机点和GC处理对象规模：  
> 完全可以在每个删除外部引用的时候直接发起GC然后规模是所有对象，但一个是频次问题无限发起，一个是规模问题爆炸增长且重复做无用检测  
> 即使分代了提供了时机，也可以依旧检测全部Obj，还是规模问题  
本质上分代回收的算法就是进制进位逻辑，每个对象创建时机作为其时序count，假设都是10进位，一个Obj只有在第10，100，1000时序点会被纳入GC检测规模，三代的话后面就是每1000为间隔，**一个进位代每个Obj指挥被GC纳入一次，二代的时候一代的几位都与当前二代某个Obj无关**  

3. 标记清理
   **按代次规模**，找到没有外部引用的所有根(模拟删除引用，没有被引用的就是外部(或者是顶层模块的全局空间)或者**其他代次咱未被GC的节点**)，再遍历跟的图打标记，然后跟代次全部规模做差集(这里是除了外部引用外得有一个遍历全部待考察对象的途径，比如当前代次链表)  
> 非当前代次的节点也算外部引用，同比与模块的引用，因为如果发起对其他代次引用住当前代次的节点的GC，那会在他所在代次也发GC检擦，GC扩散，最终会变成没有代次规模作用的全集GC  
> 而且用户引用的节点其实也可以看作是一种在一定代次(时序时机考虑)内的过期未清理残留，比如用户引用其实在业务上已经要销毁了但实现上没有即时销毁在隔了几个代次之后才销毁，那这几个代次直接的用户全局引用其实也相当于是没有了但还没被擦除，因为GC的视角并不知道什么时候才是真正该算是无引用的节点
> 去除引用找根节点对循环引用同样有效，因为循环引用会导致引用多加一  
