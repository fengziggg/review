#####1. C structure  
1. 结构体define(摸版):    
  - 类对象结构体定义: PyObject, PyVarObject, PyTypeObject  
  - 实例对象结构体定义: PyFloatObject, PyIntObject  

2. 类对象实例(被高级语言的关键词干扰，其实都是内存对象来着):  
PyTypeObject实例化出:  
  - 上层基础类型对象: PyObject_Type(name: object), PyType_Type(name: type)  
  - 内置基础类型对象: PyFloat_Type(name: float), PyInt_Type(name:int)...  
  - 自定义类型: class XXX(object), 类的定义是硬编码的，估计运行时执行时也是将硬编码的类走与内建类型类似的流程  
    
3. 实例对象：  
  - 调用类对象比如float的构造函数float()，然后执行一段内存分配逻辑创建的 由PyFloatObject定义的实例比如3.1415926  

4. 引用关系:
  - 每一个实例对象都要引用一个类型对象：一个float实例对象3.14159的c结构体中type指针指向类对象 PyFloat_Type(name: float)
  - 类对象也是个实例对象，同样指向类型对象即更上层的PyType_Type(name: type)，同时type的类型也是指向type本身
  - 类型指向是用于存放操作方法的，即实例调用的方法都要去对应的类型实例里面找，类型实例都是单例比如float等(每种类型的定义对象只需要一个)(自定义类对象实例应该也是如此)

  - 继承关系存在类型对象里面的ob_base引用里面,即每个实例上是没单独村一份继承关系的(没必要)
  - 整体的追溯逻辑是先从实例type找到类型对象引用，然后类型对象的继承关系里面索引继承链
  -  内置的类型对象实例的继承关系都是指向 PyObject_Type(name: object)即都是继承object，自定义类的顶层基类也是，然后派生类再在派生类实例对象中保存继承关系的引用指向父类型对象实例
  -  object的父类没有继续指向自己，说是怕递归

5. 可变/不可变，定长/变长：  
  - 可变对象是只对象的内存数据会不会改变，不会改变的一般只会被引用和改指向的引用(=)，而会改变的可以做容器会被持有后修改内存上数据(一般是函数接口)，当然也可以改引用另一个对象(容器的操作符重载很多都是返回引用而不是原地操作，+， *)  
  - 定长/变长对象是指统一类型的对象不同实例size会不会变  
  - 不可变对象可能变长(int)也可能定长(float)  
  - 可变对象可能用变长头定义也可能用变长头，但实际都是变长的，同一个对象的size都会变，更别说不同对象
  - 实际变长的类型(bytes, str, list, dict)的size除了头部还要吧变长的内容也算进去(bytes:sval, str: ，list: ob_item, dict: dict_keys)

----
##### List：  
0. 可变对象，变长结构  
1. 内存结构体: PyVarObj + allocated + *ob_item + GC收集头 (头部固定3+2+3)  
2. 常用操作：增append,insert, concat, +, *, 删remove, pop，改=, 查[], index  
3. ob_item指针数组动态扩容：  
  > list_reisize: 增长模型 new_size + new_size//8 + (new_size<9)3:6，PyMem_alloc  
  > ![image](https://github.com/user-attachments/assets/6153d434-9f9c-4c09-a263-21caeb96f13c)  ❓❓（0, 4, 8, 16...怎么来），  
  > list_ass_slice: 对内存上区间数据进行修改，删除即前插(O(n))，或者直接该值，会释放对象

4. append: 检查，resize，引用，setItem
5. insert: 检查，resize，引用，前插迁移新内存上数据
6. pop: 检查，调用resize或者ass_slice，resize占用list的引用/ass_slice要预先增加一次引用
7. remove: 遍历比对后ass_slice

----
##### Dict:   
0. 可变对象，定长结构特殊处理  
1. 内存结构：GC头 + 定长头(特殊定制的定长结构) + size + ma_key(这个指针本身) + ma_val + version + ma_key的展开内容[size + fraction + used + ref + lookup + 预分配[索引表(1字节*8个==1个字) + 5个实际entry(5 * 3)]]<br>
== 3 + 6 + (5 + (1 + 15)) = 30 存储字(64位为240Byte)  
2. 预分配内存：  
  > - 触发内存分配时机: 按 **2^n** 规则扩容逻辑容量(索引覆盖空间),实际空间分配为逻辑空间的 **2/3** ，然后里面实际使用到这个界限就会触发重新分配内存的计算，这里有三个容量概念(逻辑，实际分配，实际使用)  
  > - 重新计算容量：会搜集现有的所有元素(有些已经失效逻辑删除)，根据实际元素决定新空间大小，大于上一次的实配size(逻辑size*2/3)就会扩容，小于上一次逻辑size/3就会缩容，且逻辑size都以2 ** n为卡点  
  > - 空字典预分配8个逻辑槽位，然后实际size为5  

3. 数据结构：hash表:  
  > - 这是实现map，所以是没有map的不要习惯性带入map思维，用数组实现map  
  > - 用hash实现map：给key能找到地址来取值，一般到这里就看可以实现映射了map了，但后面还有hash冲突问题，带hash冲突处理的hash表其实就是拓展加了线性搜索逻辑的hash(**已经不是原生hash**了，既有随机访问也有顺序比对)  
  > - 以线性探测为例：每一个key对应的是一连串hash值(甚至是所有hash空间，只是加了时序变量)，这些冲突可能是自己的key已经被占用的冲突，也可能是自己在线性探测的时候打算占用其他hash空间的位已经被用了(每一个key都对应一串hash槽位，那其实槽位之间都是相互冲突的就是插入时序问题)，还可能是被其他人线性探测的时候占用导致自己放不下，所以搜索和更新(也要先搜索才知道能不能用)可以看作本质还是个顺序访问机制的过程(**直接映射就是这个过程的不冲突特例**)  
  > - 链表法应该没有冲突风险高的问题但内存负担增大  

4. 数据结构: 二级索引:  
  > - 本来一级索引就可以完成map映射逻辑了(顶层结构体里面的ma_value是split模式下启用的可能就是这个用法，历史遗留), 二级索引是的entry可以按插入顺序遍历(不推荐用这个特性),文章说是为了吧预分配空间这个设计中没用到的空间节省下来，但如果用一级索引表，然后也只分配fraction个元素，当插入的时候计算到达边界就扩容不是也可以支持扩容且不会预先分配满所有逻辑size❓❓毕竟检查是否扩容只需要逻辑并不需要一定依赖索引表这个数据的状态❓❓  
  > - 删除的时候不会真的删除，只会给索引表对应槽位设置dummy状态，表示槽位到实际分配conn中断，后续继续插入key冲突的元素(一个key对应若干槽位)可能可以放入dummy更新dummy(评论区,待考证❓)，查找的时候则会直接跳过dummy且不会中断  
  > - 重新分配内存的时候则会新建索引表，比如根据实际元素重建索引，无用的dummy会被下面的冲突key取缔  





