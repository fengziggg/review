#####1. C structure  
1. 结构体define(摸版):    
  - 类对象结构体定义: PyObject, PyVarObject, PyTypeObject  
  - 实例对象结构体定义: PyFloatObject, PyIntObject  

2. 类对象实例(被高级语言的关键词干扰，其实都是内存对象来着):  
PyTypeObject实例化出:  
  - 上层基础类型对象: PyObject_Type(name: object), PyType_Type(name: type)  
  - 内置基础类型对象: PyFloat_Type(name: float), PyInt_Type(name:int)...  
  - 自定义类型: class XXX(object), 类的定义是硬编码的，估计运行时执行时也是将硬编码的类走与内建类型类似的流程  
    
3. 实例对象：  
  - 调用类对象比如float的构造函数float()，然后执行一段内存分配逻辑创建的 由PyFloatObject定义的实例比如3.1415926  

4. 引用关系:
  - 每一个实例对象都要引用一个类型对象：一个float实例对象3.14159的c结构体中type指针指向类对象 PyFloat_Type(name: float)
  - 类对象也是个实例对象，同样指向类型对象即更上层的PyType_Type(name: type)，同时type的类型也是指向type本身
  - 类型指向是用于存放操作方法的，即实例调用的方法都要去对应的类型实例里面找，类型实例都是单例比如float等(每种类型的定义对象只需要一个)(自定义类对象实例应该也是如此)

  - 继承关系存在类型对象里面的ob_base引用里面,即每个实例上是没单独村一份继承关系的(没必要)
  - 整体的追溯逻辑是先从实例type找到类型对象引用，然后类型对象的继承关系里面索引继承链
  -  内置的类型对象实例的继承关系都是指向 PyObject_Type(name: object)即都是继承object，自定义类的顶层基类也是，然后派生类再在派生类实例对象中保存继承关系的引用指向父类型对象实例
  -  object的父类没有继续指向自己，说是怕递归

5. 可变/不可变，定长/变长：  
  - 可变对象是只对象的内存数据会不会改变，不会改变的一般只会被引用和改指向的引用(=)，而会改变的可以做容器会被持有后修改内存上数据(一般是函数接口)，当然也可以改引用另一个对象(容器的操作符重载很多都是返回引用而不是原地操作，+， *)  
  - 定长/变长对象是指统一类型的对象不同实例size会不会变  
  - 不可变对象可能变长(int)也可能定长(float)  
  - 可变对象可能用变长头定义也可能用变长头，但实际都是变长的，同一个对象的size都会变，更别说不同对象
  - 实际变长的类型(bytes, str, list, dict)的size除了头部还要吧变长的内容也算进去(bytes:sval, str: ，list: ob_item, dict: dict_keys)

----
##### List：  
0. 可变对象，变长结构  
1. 内存结构体: PyVarObj + allocated + *ob_item + GC收集头 (头部固定3+2+3)  
2. 常用操作：增append,insert, concat, +, *, 删remove, pop，改=, 查[], index  
3. ob_item指针数组动态扩容：  
  > list_reisize: 增长模型 new_size + new_size//8 + (new_size<9)3:6，PyMem_alloc  
  > ![image](https://github.com/user-attachments/assets/6153d434-9f9c-4c09-a263-21caeb96f13c)  ❓❓（0, 4, 8, 16...怎么来），  
  > list_ass_slice: 对内存上区间数据进行修改，删除即前插(O(n))，或者直接该值，会释放对象

4. append: 检查，resize，引用，setItem
5. insert: 检查，resize，引用，前插迁移新内存上数据
6. pop: 检查，调用resize或者ass_slice，resize占用list的引用/ass_slice要预先增加一次引用
7. remove: 遍历比对后ass_slice

----
##### Dict:   
0. 可变对象，定长结构特殊处理  
1. 内存结构：GC头 + 定长头(特殊定制的定长结构) + size + ma_key(这个指针本身) + ma_val + version + ma_key的展开内容[size + fraction + used + ref + lookup + 预分配[索引表(1字节*8个==1个字) + 5个实际entry(5 * 3)]]<br>
== 3 + 6 + (5 + (1 + 15)) = 30 存储字(64位为240Byte)  
2. 预分配内存：  
  > - 触发内存分配时机: 按 **2^n** 规则扩容逻辑容量(索引覆盖空间),实际空间分配为逻辑空间的 **2/3** ，然后里面实际使用到这个界限就会触发重新分配内存的计算，这里有三个容量概念(逻辑，实际分配，实际使用)  
  > - 重新计算容量：会搜集现有的所有元素(有些已经失效逻辑删除)，根据实际元素决定新空间大小，大于上一次的实配size(逻辑size*2/3)就会扩容，小于上一次逻辑size/3就会缩容，且逻辑size都以2 ** n为卡点  
  > - 空字典预分配8个逻辑槽位，然后实际size为5  

3. 数据结构：hash表:  
  > - 这是实现map，所以是没有map的不要习惯性带入map思维，用数组实现map  
  > - 用hash实现map：给key能找到地址来取值，一般到这里就看可以实现映射了map了，但后面还有hash冲突问题，带hash冲突处理的hash表其实就是拓展加了线性搜索逻辑的hash(**已经不是原生hash**了，既有随机访问也有顺序比对)  
  > - 以线性探测为例：每一个key对应的是一连串hash值(甚至是所有hash空间，只是加了时序变量)，这些冲突可能是自己的key已经被占用的冲突，也可能是自己在线性探测的时候打算占用其他hash空间的位已经被用了(每一个key都对应一串hash槽位，那其实槽位之间都是相互冲突的就是插入时序问题)，还可能是被其他人线性探测的时候占用导致自己放不下，所以搜索和更新(也要先搜索才知道能不能用)可以看作本质还是个顺序访问机制的过程(**直接映射就是这个过程的不冲突特例**)  
  > - 链表法应该没有冲突风险高的问题但内存负担增大  

4. 数据结构: 二级索引:  
  > - 本来一级索引就可以完成map映射逻辑了(顶层结构体里面的ma_value是split模式下启用的可能就是这个用法，历史遗留), 二级索引是的entry可以按插入顺序遍历(不推荐用这个特性),文章说是为了吧预分配空间这个设计中没用到的空间节省下来，但如果用一级索引表，然后也只分配fraction个元素，当插入的时候计算到达边界就扩容不是也可以支持扩容且不会预先分配满所有逻辑size❓❓毕竟检查是否扩容只需要逻辑并不需要一定依赖索引表这个数据的状态❓❓  
  > - 删除的时候不会真的删除，只会给索引表对应槽位设置dummy状态，表示槽位到实际分配conn中断，后续继续插入key冲突的元素(一个key对应若干槽位)可能可以放入dummy更新dummy(评论区,待考证❓)，查找的时候则会直接跳过dummy且不会中断  
  > - 重新分配内存的时候则会新建索引表，比如根据实际元素重建索引，无用的dummy会被下面的冲突key取缔  

----- 
##### 作用域与命名空间  
作用域语法静态划分依据：
对象: 属性空间(__dict__), 堆空间  
模块：模块对象，全局命名空间，也是属性空间，堆空间  
函数：局部命名空间，栈空间  
嵌套情况：  
函数嵌套函数，函数嵌套类，跨作用域或者说在子作用域内传递，有专门的命名空间闭包，不清楚是栈还是堆❓  
类嵌套函数: 必须通过self访问，其实类的属性空间并没有给函数留空间而是直接按类名划分了空间然后绑定到类上其实是一类特殊的全局函数，通过首参self表征实例空间的访问❓  
类嵌套类：没有self定义入口，可能是语法没有覆盖到的部分了，不做讨论  
所有的函数和类都相当于对全局命名空间的嵌套，但不会用到闭包空间，这个全局命名空间可以看作嵌套的特殊表达  
名字可见规则：...

命名空间的访问顺序：  
与作用域名字辐射范围相反，辐射层级嵌套越少，越优先访问，LEGB

----
##### 函数对象：  
对象职责划分:  
> 对象的主要职责是储存数据(几乎都是引用)，然后各类型的对象只不过是职责不同储存不同类型数据
> 函数对象主要存储codeObj并且主要功能是执行里面的指令
> 模块对象的主要职责是提供动态访问修改的存储空间，但比较模糊的是模块对象也带有函数行为，第一次import的时候也可以视为是执行模块全局指令

虚拟机运行时个角色划分:  
> codeObj: 编译阶已经划分好各个codeObj，codeObj之间的引用关系由co_consts维护，直接用链表方式引用住  
> > 提供字节码，co_names命名表(没有存储用到的对象本身，只存了命名然后去全局空间找)，co_consts常量表(或者叫单例表，里面包含codeObj，也包含类似int等常量，即codeObj创建出来后都是单例且引用关系也固定了)  

> module: 程序肯定有一个main模块作为入口，这个时候main模块的定位既是函数会执行里面的全局指令，也是存储空间提供dict作为该模块下的global  
> > 指令无非常见运算(方法调用)和def(也是一种运算)和import(也是一种运算),def会在堆空间创建function对象(会存储子codeObj引用)供后面其他运算使用(call时候的LOADNAME)，第一次import也会执行该模块里面的指令，该运算运算该定义定义，不知道有没有开辟帧❓  
> > 模块的属性空间会作为该模块下所有子codeObj运行时依赖的一切全局数据的来源，即一个模块下的子CodeObj的非栈非静态空间都是派生自这个模块的属性空间，而模块间是没有这种子承关系的，即使是main也不是其他所有模块的父global空间，即命名空间在模块就到顶了  
> > 模块的定位比较暧昧，既像特殊函数(第一次import时或者reimport)会执行指令，又像命名空间的基本单位模块提供global

> frameObj: callfunc的时候开辟新上下文(状态机)，主要存了上述两者的引用关联起两者    
> > iLast指引该状态机下对应的codeObj执行到哪  
> > 提供各种空间的引用global，local，varplus什么的，codeObj执行的时候查co_names找对应的对象就在framObj指明的这些空间里面找  
> > 递归的时候是同一个codeObj，每个帧对象都指向同一个codeObj但是iLast不一样，然后一个codeObj执行结束返回值存储在上一个帧对象的临时变量栈的某个位置上，然后继续该栈的运算

> function: 主要提供对codeObj的引用，自己也记录了对global等的引用，但是local没有，忘了细看原因  
![d870fba9c1f6a8283f64d7b475679d0](https://github.com/user-attachments/assets/0bf56bd1-2713-4e52-931c-2204c55c9c55)  
真正的指令执行者都是codeObj

----
##### 类


